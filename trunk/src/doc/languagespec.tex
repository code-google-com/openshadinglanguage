\documentclass[11pt,letterpaper]{book}
\setlength{\oddsidemargin}{0.5in}
\setlength{\topmargin}{0in}
\setlength{\evensidemargin}{0.3in}
\setlength{\textwidth}{5.75in}
\setlength{\textheight}{8.5in}
%\setlength{\oddsidemargin}{1.25in}
%\setlength{\evensidemargin}{0.5in}

% don't do this \usepackage{times}    % Better fonts than Computer Modern
\renewcommand{\sfdefault}{phv}
\renewcommand{\rmdefault}{ptm}
% don't replace tt -- old is better \renewcommand{\ttdefault}{pcr}
%\usepackage{apalike}
\usepackage{pslatex}
\usepackage{techref}
\usepackage{epsfig}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{multicol}
\usepackage{color}
\usepackage{html}
\usepackage{version}
\usepackage{makeidx}
%\usepackage{showidx}
\usepackage[chapter]{algorithm}
\floatname{algorithm}{Listing}

\usepackage{syntax}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\fancyfoot[C]{\bfseries Unnamed Shading Language Documentation}
\renewcommand{\footrulewidth}{1pt}


\def\langname{Unnamed Shading Language\xspace}
\def\product{{\sffamily Unnamed Shading Language}\xspace}
\def\versionnumber{0.1}
\def\productver{\product\ {\sffamily \versionnumber}\xspace}


\title{ 
{\Huge{\bf \product}
%\textregistered\ 
{\bf\sffamily \versionnumber} \medskip \\ \huge 
Language Specification
\\ \large (draft in progress) 
} \bigskip }
\author{Editor: Editor's Name \\
% email should go here
 \bigskip \\
}
\date{{\large Date: 16 October, 2008}}


\include{macros}

\def\color{{\cf color}\xspace}
\def\float{{\cf float}\xspace}
\def\inttype{{\cf int}\xspace}
\def\matrix{{\cf matrix}\xspace}
\def\normal{{\cf normal}\xspace}
\def\point{{\cf point}\xspace}
\def\vector{{\cf vector}\xspace}
\def\void{{\cf void}\xspace}
\def\I{{\cf I}\xspace}
\def\N{{\cf N}\xspace}
\def\Ng{{\cf N}\xspace}
\def\P{{\cf P}\xspace}
\def\currentspace{{\cf "current"} space\xspace}
\def\commonspace{{\cf "common"} space\xspace}
\def\shaderspace{{\cf "shader"} space\xspace}
\def\worldspace{{\cf "world"} space\xspace}
\def\cameraspace{{\cf "camera"} space\xspace}
\def\objectspace{{\cf "object"} space\xspace}
\def\rgbspace{{\cf "rgb"} space\xspace}
\def\noise{{\cf noise()}\xspace}
\def\snoise{{\cf snoise()}\xspace}
\def\pnoise{{\cf pnoise()}\xspace}
\def\psnoise{{\cf psnoise()}\xspace}
\def\cellnoise{{\cf cellnoise()}\xspace}
\def\illuminance{{\cf illuminance}\xspace}
\def\illuminate{{\cf illuminate}\xspace}




\makeindex

\begin{document}
\frontmatter

\maketitle

%\include{speccopyr}

\vspace*{2in}




\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

%\part{Part name}

%\include{blah}


\chapter{Basic Structure}
\label{chap:shaderstructure}

\chapter{Shader types and structure}
\label{chap:shadertypes}

\section{Shader types}
\label{sec:shadertypes}
\index{shader types} \index{types!shader}

\section{Shader parameters}
\label{sec:shaderparams}
\index{shader parameters} \index{parameters!shader}

    how shader parameters get their values

\section{Shader metadata}
\label{sec:metadata}
\index{metadata} \index{shader metadata}

\chapter{Lexical structure}
\label{chap:lexical}

\section{Characters}
\label{sec:lexical:chars}
\index{character set}

Source code for \langname consists of ASCII or UTF-8 characters.

The characters for space, tab, carriage return, and linefeed are
collectively referred to as \emph{whitespace}.  Whitespace characters
delimit identifiers, keywords, or other symbols, but other than that
have no syntactic meaning.  Multiple whitespace characters in a row
are equivalent to a single whitespace character. \index{whitespace}

Source code may be split into multiple lines, separated by end-of-line
markers (carriage return and/or linefeed).  Lines may be of any length
and end-of-line markers carry no significant difference from other 
whitespace, except that they terminate {\cf //} comments and delimit
preprocessor directives.

\section{Identifiers}
\label{sec:identifiers}
\index{identifiers}

\emph{Identifiers} are the names of variables, parameters, functions,
and shaders.  In \langname, identifiers consist of one or more
characters.  The first character may be a letter ({\cf A}-{\cf Z} or
{\cf a}-{\cf z}) or underscore (\verb|_|), and subsequent characters may
be letters, underscore, or numerals ({\cf 0}-{\cf 9}).  Examples of
valid and invalid identifiers are:

\begin{code}
    opacity       // valid
    Long_name42   // valid - letters, underscores, numbers are ok
    _foo          // valid - ok to start with an unberscore

    2smart        // invalid - starts with a numeral
    bigbuck$      // invalid - $ is an illegal character
\end{code}


\section{Comments}
\label{sec:comments}
\index{comments}

\emph{Comments} are text that are for the human reader of programs, and
are ignored entirely by the \langname compiler.  Just like in C++, there
are two ways to designate comments in \langname:

\begin{enumerate}
\item Any text enclused by {\cf /*} and {\cf */} will be considered
a comment, even if the comment spans several lines.

\begin{code}
    /* this is a comment */

    /* this is also
       a comment, spanning
       several lines */
\end{code}

\item Any text following {\cf //}, up to the end of the current line,
will be considered a comment.

\begin{code}
    // This is a comment
    a = 3;   // another comment
\end{code}
\end{enumerate}


\section{Keywords and reserved words}
\label{sec:lexical:keyreserved}

There are two sets of names that you may not use as identifiers:
keywords and reserved words.

The following are \emph{keywords} that have special meaning in
\langname: \index{keywords}

\begin{code}
FIXME
\end{code}

The following are \emph{reserved words} that currently have no special
meaning in \langname, but we reserve them for possible future use, or
becuase they are confusingly similar to keywords in related programming
languages: \index{reserved words}

\begin{code}
FIXME
\end{code}


\section{Preprocessor}
\label{sec:preprocessor}
\index{preprocessor} \index{C preprocessor|see{preprocessor}}
\indexapi{\#define}
\indexapi{\#undef}
\indexapi{\#if}
\indexapi{\#ifdef}
\indexapi{\#ifndef}
\indexapi{\#elif}
\indexapi{\#else}
\indexapi{\#endif}
\indexapi{\#include}

Shader source code is passed through a standard C preprocessor as a
first step in parsing.  

Preprocessor directives are designated by a hash mark ({\cf \#}) as the
first character on a line, followed by a preprocessor directive name.
Whitespace may optionally appear between the hash and the directive
name.

\langname compilers support the full complement of C/C++ preprocessing
directives, including:

\begin{code}
    #define
    #undef
    #if
    #ifdef
    #ifndef
    #elif
    #else
    #endif
    #include
\end{code}



\chapter{Data types}
\label{chap:types}
\index{types|(}

\langname provides several built-in data types for performing
computations inside your shader:
\smallskip

\noindent\begin{tabular}{|p{0.75in}|p{4.75in}|}
\hline
{\cf int}	& Integer data \\[1ex]
%\hline
{\cf float}	& Scalar floating-point data (numbers) \\[1ex]
%\hline
{\cf point
vector
normal}		& Three-dimensional positions, directions, and surface
		  orientations \\[7ex]
%\hline
{\cf color}	& Spectral reflectivities and light energy values \\[1ex]
%\hline
{\cf matrix}	& $4 \times 4$ transformation matrices \\[1ex]
%\hline
{\cf string}	& Character strings (such as filenames) \\[1ex]
{\cf void}      & Indicates functions that do not return a value \\[1ex]
\hline
\end{tabular}


\section{{\cf int}}
\label{sec:types:int}
\indexapi{int} \index{types!{\cf int}}

The basic type for discrete numeric values is {\cf int}.  The size of
the {\cf int} type is renderer-dependent, but is guaranteed to be at
least 32 bits.

Integer constants are constructed the same way as in C.  The following
are examples of {\cf int} constants: {\cf 1}, {\cf -32}, etc.

Unlike C, no unsigned, bool, char, short, or long types are supplied.
This is to simplify the process of writing shaders (as well as
implementing shading systems).

The following operators may be used with \inttype values (in order of
decreasing precedence, with each box holding operators of the same
precedence):

\smallskip

\noindent \begin{tabular}{|p{1in}|p{0.5in}|p{3.75in}|}
operation & result & ~ \\
\hline
\inttype\ {\ce ++} & \inttype & post-increment by 1 \\[0.5ex]
\inttype\ {\ce --} & \inttype & post-decrement by 1 \\[0.5ex]
\hline
{\ce ++} \inttype & \inttype & pre-increment by 1 \\[0.5ex]
{\ce --} \inttype & \inttype & pre-decrement by 1 \\[0.5ex]
{\cf {\bfseries -} int} & \inttype & unary negation \\[0.5ex]
\verb|~| {\cf int} & \inttype & bitwise complement (1 and 0 bits flipped) \\[0.5ex]
{\cf {\bfseries !} int} & \inttype & boolean `not' (1 if operand is zero, otherwise 0) \\[0.5ex]
\hline
{\cf int {\bfseries *} int} & \inttype & multiplication \\[0.5ex]
{\cf int {\bfseries /} int} & \inttype & division \\[0.5ex]
{\cf int {\bfseries \%} int} & \inttype & modulus \\[0.5ex]
\hline
{\cf int {\bfseries +} int} & \inttype & addition \\[0.5ex]
{\cf int {\bfseries -} int} & \inttype & subtraction \\[0.5ex]
\hline
{\cf int {\bfseries <<} int} & \inttype & shift left \\[0.5ex]
{\cf int {\bfseries >>} int} & \inttype & shift right \\[0.5ex]
\hline
{\cf int {\bfseries <} int} & \inttype & 1 if the first value is less
than the second, else 0 \\[0.5ex]
{\cf int {\bfseries <=} int} & \inttype & 1 if the first value is less
or equal to the second, else 0 \\[0.5ex]
{\cf int {\bfseries >} int} & \inttype &  1 if the first value is
greater than the second, else 0 \\[0.5ex]
{\cf int {\bfseries >=} int} & \inttype & 1 if the first value is
greater than or equal to the second, else 0 \\[0.5ex]
\hline
{\cf int {\bfseries ==} int} & \inttype & 1 if the two values are equal,
else 0 \\[0.5ex]
{\cf int {\bfseries !=} int} & \inttype & 1 if the two values are different,
else 0 \\[0.5ex]
\hline
{\cf int {\bfseries \&} int} & \inttype & bitwise and \\[0.5ex]
\hline
{\cf int {\bfseries \verb|^|} int} & \inttype & bitwise exclusive or \\[0.5ex]
\hline
{\cf int {\bfseries |} int} & \inttype & bitwise or \\[0.5ex]
\hline
{\cf int {\bfseries \&\&} int} & \inttype & boolean and (1 if both operands are
nonzero, otherwise 0) \\[0.5ex]
\hline
{\cf int {\bfseries ||} int} & \inttype & boolean or (1 if either operand is
nonzero, otherwise 0) \\[0.5ex]
\hline
\end{tabular}



\begin{annotate}
Make sure to rearrange the table in order of operator precedence.
\end{annotate}

\section{{\cf float}}
\label{sec:types:float}
\indexapi{float} \index{types!{\cf float}}

The basic type for scalar floating-point numeric values is \float.  The
size of the {\cf float} type is renderer-dependent, but is guaranteed to
be at least IEEE 32-bit float (the standard C \float data type).
Individual renderer implementations may choose to implement \float with
even more precision (such as using the C {\cf double} as the underlying
representation).

Floating-point constants are constructed the same way as in C.
The following are examples of {\cf float} constants:  {\cf 1.0},
{\cf 2.48}, {\cf -4.3e2}.

An \inttype may be used in place of a \float when used with any valid
\float operator.  In such cases, the \inttype will be promoted to a
\float and the resulting expression will be \float.  An \inttype may
also be passed to a function that expects a \float parameters, with the
\inttype automatically promoted to \float.

The following operators may be used with \float values (in order of
decreasing precedence, with each box holding operators of the same
precedence):

\medskip

\noindent \begin{tabular}{|p{1.25in}|p{0.5in}|p{3.5in}|}
operation & result & ~ \\
\hline
\float\ {\ce ++} & \float & post-increment by 1 \\[0.5ex]
\float\ {\ce --} & \float & post-decrement by 1 \\[0.5ex]
\hline
{\ce ++} \float & \float & pre-increment by 1 \\[0.5ex]
{\ce --} \float & \float & pre-decrement by 1 \\[0.5ex]
{\cf {\bfseries -} float} & \float & unary negation \\[0.5ex]
\hline
{\cf float {\bfseries *} float} & \float & multiplication \\[0.5ex]
{\cf float {\bfseries /} float} & \float & division \\[0.5ex]
\hline
{\cf float {\bfseries +} float} & \float & addition \\[0.5ex]
{\cf float {\bfseries -} float} & \float & subtraction \\[0.5ex]
\hline
{\cf float {\bfseries <} float} & \inttype & 1 if the first value is less
than the second, else 0 \\[0.5ex]
{\cf float {\bfseries <=} float} & \inttype & 1 if the first value is less
or equal to the second, else 0 \\[0.5ex]
{\cf float {\bfseries >} float} & \inttype &  1 if the first value is
greater than the second, else 0 \\[0.5ex]
{\cf float {\bfseries >=} float} & \inttype & 1 if the first value is
greater than or equal to the second, else 0 \\[0.5ex]
\hline
{\cf float {\bfseries ==} float} & \inttype & 1 if the two values are equal,
else 0 \\[0.5ex]
{\cf float {\bfseries !=} float} & \inttype & 1 if the two values are different,
else 0 \\[0.5ex]
\hline
\end{tabular}



\section{{\cf color}}
\label{sec:types:color}
\indexapi{color} \index{types!{\cf color}}

The \color type is used to represent 3-component (RGB) spectral
reflectivities and light energies.  You can assemble a
color out of three floats, either representing an RGB triple or some
other color space known to the renderer, as well as from a single
float (replicated for all three channels).  Following are some examples:

\begin{code}
    color (0, 0, 0)              // black
    color ("rgb", .75, .5, .5)   // pinkish
    color ("hsv", .2, .5, .63)   // specify in "hsv" space
    color (0.5)                  // same as color (0.5, 0.5, 0.5)
\end{code}

All these expressions above return colors in \rgbspace.  Even
the third example returns a color in \rgbspace\ --- specifically, the
RGB value of the color that is equivalent to hue 0.2, saturation 0.5,
and value 0.63.  In other words, when assembling a color from components
given relative to a specific color space in this manner, there is an
implied transformation to \rgbspace.  Table~\ref{tab:colorspacenames}
lists the built-in color spaces.

\begin{table}[htbp]
\caption{Names of color spaces.}\label{tab:colorspacenames}
\begin{tabular}{|p{0.7in}|p{4.7in}|}
\hline
{\cf "rgb"} & The coordinate system that all colors start out in, and
in which the renderer expects to find colors that are set by
your shader (such as {\cf C}, {\cf opacity}, and {\cf Cl}).   \\
\hline 
{\cf "hsv"} & hue, saturation, and value. \\
\hline 
{\cf "hsl"} & hue, saturation, and lightness. \\
\hline 
{\cf "YIQ"} & the color space used for the NTSC television standard. \\
\hline 
{\cf "xyz"} & CIE \emph{XYZ} coordinates. \\
\hline 
{\cf "xyY"} & CIE \emph{xyY} coordinates. \\
\hline 
\end{tabular}
\end{table}

Colors may be assigned another color or a \float value (which sets
all three components to the value).  For example:

\begin{code}
    color C;
    C = color (0, 0.3, 0.3);
    C = 0.5;                    // same as C = color (0.5, 0.5, 0.5)
\end{code}

Colors can have their individual components examined and set using the
{\cf []} array access notation.  For example:

\begin{code}
    color C;
    float g = C[1];   // get the green component
    C[0] = 0.5;       // set the red component
\end{code}

\noindent Components 0, 1, and 2 are red, green, and blue, respectively.
It is an error to access a color component with an index outside the
$[0...2]$ range.

The following operators may be used with \color values (in order of
decreasing precedence, with each box holding operators of the same
precedence):

\medskip

\noindent \begin{tabular}{|p{1.5in}|p{0.5in}|p{3.25in}|}
operation & result & ~ \\
\hline
\color\ {\ce [} \inttype {\ce ]} & \float & component access \\[0.5ex]
\hline
{\ce -} \color & \color & unary negation \\[0.5ex]
\hline
\color\ {\ce *} \color & \color & component-wise multiplication \\[0.5ex]
\color\ {\ce *} \float & \color & scaling \\[0.5ex]
\float\ {\ce *} \color & \color & scaling \\[0.5ex]
\color\ {\ce /} \color & \color & component-wise division \\[0.5ex]
\color\ {\ce /} \float & \color & scaling \\[0.5ex]
\float\ {\ce /} \color & \color & scaling \\[0.5ex]
\hline
\color\ {\ce +} \color & \color & component-wise addition \\[0.5ex]
\color\ {\ce -} \color & \color & component-wise subtraction \\[0.5ex]
\hline
\color\ {\ce ==} \color & \inttype & 1 if the two values are equal,
else 0 \\[0.5ex]
\color\ {\ce !=} \color & \inttype & 1 if the two values are different,
else 0 \\[0.5ex]
\hline
\end{tabular}

All of the binary operators may combine a scalar value (\float or
\inttype) with a \color, treating the scalar if it were a \color with
three identical components.


\section{Point-like types: {\cf point}, {\cf vector}, {\cf normal}}
\label{sec:types:point}
\indexapi{point} \indexapi{vector} \indexapi{normal}
\index{types!{\cf point}} \index{types!{\cf vector}} \index{types!{\cf normal}}

Points, vectors, and normals are similar data types with identical
structures but subtly different semantics.  We will frequently refer to
them collectively as the ``point-like'' data types when making
statements that apply to all three types.

A \point is a position in 3D space.  A \vector has a length and
direction, but does not exist in a particular location.  A \normal is a
special type of vector that is \emph{perpendicular} to a surface, and
thus describes the surface's orientation.  Such a perpendicular vector
uses different transformation rules than ordinary vectors, as we will
describe below.

All of these point-like types are internally represented by three
floating-point numbers that uniquely describe a position or
direction relative to the three axes of some coordinate system.  

All points, vectors, and normals are described relative to some
coordinate system.  All data provided to a shader (surface information,
graphics state, parameters, and vertex data) are relative to one
particular coordinate system that we call the {\cf "common"} coordinate
system.  The {\cf "common"} coordinate system is one that is convenient
for the renderer's shading calculations.
\label{sect:commonspace}

You can ``assemble'' a point-like type out of three floats using a
constructor:

\begin{code}
        point (0, 2.3, 1)
        vector (a, b, c)
        normal (0, 0, 1)
\end{code}

\noindent These expressions are interpreted as a point, vector, and normal
whose three components are the floats given, relative to \commonspace\ .

As with colors, you may also specify the coordinates relative to some other
coordinate system:

\begin{code}
    Q = point ("object", 0, 0, 0);
\end{code}

This example assigns to {\cf Q} the point at the origin of
\objectspace.  However, this statement does \emph{not} set the
components of {\cf Q} to (0,0,0)!  Rather, {\cf Q} will contain the
\commonspace\ coordinates of the point that is at the same location as
the origin of \objectspace.  In other words, the point constructor that
specifies a space name implicitly specifies a transformation
to \commonspace.  This type of constructor also can be used for vectors
and normals.

The choice of \commonspace is renderer-dependent, though will usually
be equivalent to either \cameraspace or \worldspace.

Some computations may be easier in a coordinate system other than
\currentspace.  For example, it is much more convenient to apply a
``solid texture'' to a moving object in its \objectspace than in
\currentspace.  For these reasons, SL provides built-in functions that
allow you to transform points among different coordinate systems.  The
built-in functions {\cf transform, vtransform, ntransform} can be used
to transform points, vectors, and normals, respectively, from one
coordinate system to another (see Section~\ref{chap:stdlibrary}).  Note,
however, that \langname does not keep track of which point variables are
in which coordinate systems.  It is the responsibility of the shader
programmer to keep track of this and ensure that, for example, lighting
computations are performed using quantities in \commonspace.

Be very careful to use the right transformation routines for the right
point-like types.  Transforming with the wrong matrix math will
introduce subtle and difficult-to-fix errors in your code.  Therefore,
it is important to always use {\cf transform} for points, {\cf
  vtransform} for vectors, and {\cf ntransform} for normals.

Several coordinate systems are predefined by name, listed in
Table~\ref{tab:spacenames}.  Additionally, a renderer will probably
allow for additional coordinate systems to be named in the scene
description, and these names may also be referenced inside your shader
to designate transformations.

\begin{table}[htbp]
\caption{Names of predeclared geometric spaces.\label{tab:spacenames}}
\begin{tabular}{|p{0.7in}|p{4.7in}|}
\hline
{\cf "common"} & The coordinate system that all spatial values start out in and
the one in which all lighting calculations are carried out.  Note that
the choice of {\cf "common"} space may be different on each renderer. \\
\hline 
{\cf "object"} & The local coordinate system of the graphics primitive (sphere,
patch, etc.) that we are shading. \\
\hline 
{\cf "shader"} & The local coordinate system active at the time that the shader
was instanced. \\
\hline 
{\cf "world"} & The world coordinate system designated in the scene. \\
\hline 
{\cf "camera"} & The coordinate system with its origin at the center of
the camera lens, $x$-axis pointing right, $y$-axis pointing up, and
$z$-axis pointing into the screen. \\
\hline 
{\cf "screen"} & The coordinate system of the camera's image plane
(after perspective transformation, if any).  Coordinate (0,0) of {\cf
"screen"} space is looking along the $z$-axis of \cameraspace. \\
\hline 
{\cf "raster"} & 2D pixel coordinates, with (0,0) as the upper-left
corner of the image and (xres, yres) as the lower-right corner. \\
\hline 
{\cf "NDC"} & 2D Normalized Device Coordinates --- like raster space, but
normalized so that $x$ and $y$ both run from 0 to 1 across the whole
image, with (0,0) being at the upper left of the image, and (1,1) being
at the lower right. \\
\hline 
\end{tabular}
\end{table}

Point types can have their individual components examined and set using
the {\cf []} array access notation.  For example:

\begin{code}
    point P;
    float y = P[1];   // get the y component
    P[0] = 0.5;       // set the x component
\end{code}

\noindent Components 0, 1, and 2 are $x$, $y$, and $z$, respectively.
It is an error to access a point component with an index outside the
$[0...2]$ range.

The following operators may be used with point-like values (in order of
decreasing precedence, with each box holding operators of the same
precedence):

\medskip

\noindent \begin{tabular}{|p{1.5in}|p{0.5in}|p{3.25in}|}
operation & result & ~ \\
\hline
\emph{ptype}\ {\ce [} \inttype {\ce ]} & \float & component access \\[0.5ex]
\hline
{\ce -} \emph{ptype} & \vector & component-wise unary negation \\[0.5ex]
\hline
\emph{ptype}\ {\ce *} \emph{ptype} & \emph{ptype} & component-wise multiplication \\[0.5ex]
\float\ {\ce *} \emph{ptype} & \emph{ptype} & scaling of all components \\[0.5ex]
\emph{ptype}\ {\ce *} \float & \emph{ptype} & scaling of all components \\[0.5ex]
\emph{ptype}\ {\ce /} \emph{ptype} & \emph{ptype} & component-wise division \\[0.5ex]
\emph{ptype}\ {\ce /} \float & \emph{ptype} & division of all components \\[0.5ex]
\float\ {\ce /} \emph{ptype} & \emph{ptype} & division by all components \\[0.5ex]
\hline
\emph{ptype}\ {\ce +} \emph{ptype} & \emph{ptype} & component-wise addition \\[0.5ex]
\emph{ptype}\ {\ce -} \emph{ptype} & \vector & component-wise subtraction \\[0.5ex]
\hline
\emph{ptype}\ {\ce ==} \emph{ptype} & \inttype & 1 if the two values are equal,
else 0 \\[0.5ex]
\emph{ptype}\ {\ce !=} \emph{ptype} & \inttype & 1 if the two values are different,
else 0 \\[0.5ex]
\hline
\end{tabular}

\smallskip

\noindent The generic \emph{ptype} is listed in places where any
of \point, \vector, or \normal may be used.

All of the binary operators may combine a scalar value (\float or
\inttype) with a point-like type, treating the scalar if it were
point-like with three identical components.


\section{{\cf matrix}}
\label{sec:types:matrix}
\indexapi{matrix} \index{types!{\cf matrix}}

\langname has a \matrix type that represents the transformation matrix
required to transform points and vectors between one coordinate system
and another.  Matrices are represented internally by 16 floats (a $4
\times 4$ homogeneous transformation matrix).

A \matrix can be constructed from a single float or 16 floats.  For
example:

\begin{code}
    matrix zero = 0;   // makes a matrix with all 0 components
    matrix ident = 1;  // makes the identity matrix

    // Construct a matrix from 16 floats
    matrix m = matrix (m00, m01, m02, m03, m10, m11, m12, m13, 
                       m20, m21, m22, m23, m30, m31, m32, m33);
\end{code}

\noindent Assigning a single floating-point number $x$ to a matrix will result
in a matrix with diagonal components all being $x$ and other
components being zero (i.e., $x$ times the identity matrix).
Constructing a matrix with 16 floats will create the matrix whose
components are those floats, in row-major order.  

Similar to point-like types, a {\cf matrix} may be constructed in
reference to a named space:

\begin{code}
    // Construct matrices relative to something other than "common"
    matrix q = matrix ("shader", 1);
    matrix m = matrix ("world", m00, m01, m02, m03, m10, m11, m12, m13, 
                               m20, m21, m22, m23, m30, m31, m32, m33);
\end{code}

\noindent The first form creates the matrix that transforms points from
\currentspace to \shaderspace.  Transforming points by this matrix
is identical to calling {\cf transform("shader",...)}.
The second form prepends the current-to-world transformation matrix
onto the $4 \times 4$ matrix with components $m_{0,0} ... m_{3,3}$.
Note that although we have used {\cf "shader"} and {\cf "world"}
space in our examples, any named space is acceptable.

Matrix variables can be tested for equality and inequality with the
{\cf ==} and {\cf !=} boolean operators.  Also, the {\cf *} operator
between matrices denotes matrix multiplication, while {\cf m1 / m2}
denotes multiplying {\cf m1} by the inverse of matrix {\cf m2}.  Thus,
a matrix can be inverted by writing {\cf 1/m}.  In addition, some
functions will accept matrix variables as arguments, as described in
Section~\ref{chap:stdlibrary}.

Individual compoents of a matrix variable may be set or accessed
using array notation, for example,

\begin{code}
    matrix M;
    float x = M[row][col];
    M[row][col] = 1;
\end{code}

Valid component indices are integers on $[0...3]$.  It is an error to
access a matrix component with either a row or column outside this
range.

The following operators may be used with matrices (in order of
decreasing precedence, with each box holding operators of the same
precedence):

\medskip
\noindent \begin{tabular}{|p{1.5in}|p{0.5in}|p{3.25in}|}
operation & result & ~ \\
\hline
\matrix\ {\ce [} \inttype {\ce ][} \inttype {\ce ]} & \float & component
access (row, column) \\[0.5ex]
\hline
{\ce -} \matrix & \matrix & unary negation \\[0.5ex]
\hline
\matrix\ {\ce *} \matrix & \matrix & matrix multiplication \\[0.5ex]
\matrix\ {\ce *} \float & \matrix & component-wise scaling \\[0.5ex]
\float\ {\ce *} \matrix & \matrix & component-wise scaling \\[0.5ex]
\matrix\ {\ce /} \matrix & \matrix & multiply the first matrix by the
\emph{inverse} of the second \\[0.5ex]
\matrix\ {\ce /} \float & \matrix & component-wise division \\[0.5ex]
\float\ {\ce /} \matrix & \matrix & multiply the \float by the
\emph{inverse} of the matrix \\[0.5ex]
\hline
%\matrix\ {\ce +} \matrix & \matrix & component-wise addition \\[0.5ex]
%\matrix\ {\ce -} \matrix & \matrix & component-wise subtraction \\[0.5ex]
%\hline
\matrix\ {\ce ==} \matrix & \inttype & 1 if the two values are equal,
else 0 \\[0.5ex]
\matrix\ {\ce !=} \matrix & \inttype & 1 if the two values are different,
else 0 \\[0.5ex]
\hline
\end{tabular}


\section{{\cf string}}
\label{sec:types:string}
\indexapi{string} \index{types!{\cf string}}

The {\cf string} type may hold character strings.  The main application
of strings is to provide the names of files where textures may be
found.  Strings can be compared using {\cf ==} and {\cf !=}.

String constants are denoted by surrounding the characters with double
quotes, as in \qkw{I am a string literal}.  As in C programs, string
literals may contain escape sequences such as \verb|\n| (newline),
\verb|\r| (carriage return), \verb|\t| (tab), \verb|\"| (double quote),
\verb|\\| (backslash).

\section{\void}
\label{sec:types:void}
\indexapi{void} \index{types!{\cf void}}

The \void type is used to designate a function that does not return
a value.  No variable may have type \void.

\section{Arrays}
\label{sec:types:arrays}
\index{arrays} \index{types!arrays}

Arrays of any of the basic types are supported, provided that they
are 1D and statically sized, using the usual syntax for C-like languages:

\begin{code}
    float d[10];                       // Declare an uninitilized array
    float c[3] = { 0.1, 0.2, 3.14 };   // Initialize the array

    float f = c[1];                    // Access one element
\end{code}

The built-in function {\cf arraylength()} returns the number of elements
in an array.  For example:

\begin{code}
    float c[3];
    int clen = arraylength(c);        // should return 3
\end{code}

There are two circumstances when arrays do not need to have a declared
length --- an array parameter to a function, and a shader parameter that
is an array.  This is indicated by empty array brackets, as shown in the
following example:

\begin{code}
    float sum (float x[])
    {
        float s = 0;
        for (int i = 0;  i < arraylength(x);  ++i)
            s += x[i];
        return s;
    }
\end{code}

\section{Structures}
\label{sec:types:struct}
\indexapi{struct} \index{types!structures} \index{structures|see{{\cf struct}}}

Structures are used to group several fields of potentially different
types into a single object that can be referred to by name.  You may
then use the structure type name to declare structure variables as you
would for any of the built-in types.  Structure elements are accessed
using the `dot' operator.  The syntax for declaring and using structures
is similar to C or C++:

\begin{code}
    struct ray {                   // Define a structure type
        point pos;
        vector dir;
    };

    ray r;                         // Declare a structure
    r.pos = point (1, 0, 0);       // Assign to one field
    point p = r.pos;               // Read from a structure field
\end{code}

It is permitted to have a structure field that is an array, as well as
to have an array of structures.  But it is not permitted for one
structure to have a field that is another structure.  For example:

\begin{code}
    struct A {
        color a;
        float b[4];       // struct may contain an array
    };

    A d[5];               // Array of structures
    color e = d[0].a;     // Field of one element of array of struct
    d[2].b[4] = 0.25;     // Element of a field of a struct in an array
\end{code}

\begin{annotate}
\QUESTION Is this restriction (no ``structure recursion'') acceptable?
It certainly makes the implementation of the language easier.
\end{annotate}

\index{types|)}   % end of chapter



\chapter{Language Syntax}
\label{chap:syntax}

The body of a shader is a sequence of individual \emph{statements}.
This chapter describes the types of statements and control-flow patterns
in \langname.

Statements in \langname include the following types of constructs:

\begin{itemize}
\item Scoped statements.
\item Variable declarations.
\item Expressions.
\item Assignments.
\item Control flow: {\cf if, else, while, do, for, break, continue}
\item Function declarations.
\item Lighting statements: \illuminance, \illuminate
\end{itemize}

\subsection*{Scoping}

Any place where it is legal to have a statement, it is legal to have
multiple statements enclosed by curly braces {\cf \{ \}}.  This is
called a \emph{scope}.  Any variables or functions declared declared
within a scope are only visible within that scope, and only may be used
after their declaration.  Variables or functions that are referenced
will always resolve to the matching name in the innermost scope relative
to its use.  For example

\begin{code}
    float a = 1;      // Call this the "outer" 'a'
    float b = 2;
    {
        float a = 3;  // Call this the "inner" 'a'
        float c = 1;
        b = a;        // b gets 3, because a is resolved to the inner scope
    }
    b += c;           // ERROR -- c was only in the inner scope

\end{code}



\section{Variable declarations and assignments}
\label{sec:vardeclsassignments}

\subsection{Variable declarations}
\label{sec:vardecls}
\index{variable declarations}

The syntax for declaring a variable in \langname is:

\vspace{12pt}
\spc \emph{type} \emph{name} 

\spc \emph{type} \emph{name} = \emph{value}
\vspace{12pt}

\noindent where

\begin{itemize}
\item \emph{type} is one of the basic data types, described earlier.
\item \emph{name} is the name of the variable you are declaring.
\item If you wish to initialize your variable an initial value, you may
immediately assign it a \emph{value}, which may be any valid expression.
\end{itemize}

You may declare several variables of the same type in a single
declaration by separating multiple variable names by commas:

\vspace{12pt}
\spc \emph{type} \emph{name1} {\cf ,} ~ \emph{name2} ...

\spc \emph{type} \emph{name1} [ = \emph{value1}] {\cf ,} ~ \emph{name2} [ =
  \emph{value2} ] ...
\vspace{12pt}


\noindent Some examples of variable declarations are

\begin{code}
    float a;           // Declare; current value is undefined
    float b = 1;       // Declare and assign a constant initializer
    float c = a*b;     // Computed initializer
    float d, e = 2, f; // Declare several variables of the same type
\end{code}

\subsection{Arrays}
\indexapi{arrays} \index{types!arrays}

Arrays are also supported, declared as follows:

\vspace{12pt}
\spc \emph{type} \emph{variablename}
 {\cf [} \emph{arraylen} {\cf ]}

\spc \emph{type} \emph{variablename}
 {\cf [} \emph{arraylen} {\cf ]} = {\cf \{ }
 \emph{init0}{\cf ,} \emph{init1} ... {\cf \}}
\vspace{12pt}

\noindent Array variables in \langname must have a constant length
(though function parameters and shader parameters may have undetermined
length).  Some examples of array variable declarations are:

\begin{code}
    float d[10];                       // Declare an uninitilized array
    float c[3] = { 0.1, 0.2, 3.14 };   // Initialize the array
\end{code}

\subsection{Structures}
\indexapi{struct}

Structures are used to group several fields of potentially different
types into a single object that can be referred to by name.  The syntax
for declaring a structure type is:

\vspace{12pt}
\spc {\cf struct} \emph{structname} {\cf \{} 

\spc\spc \emph{type1} \emph{fieldname1} {\cf ;}

\spc\spc ...

\spc\spc \emph{typeN} \emph{fieldnameN} {\cf ;}

\spc {\cf \} ;}
\vspace{12pt}

You may then use the structure type name to declare structure variables
as you would for any of the built-in types:

\vspace{12pt}
\spc \emph{structname} \emph{variablename} {\cf ;}

\spc \emph{structname} \emph{variablename} {\cf = \{ }
\emph{initializer1} {\cf ,} ... \emph{initializerN} {\cf \} ;}
\vspace{12pt}

If initializers are supplied, each field of the structure will be
initialized with the initializer in the corresponding position, which
is expected to be of the appropriate type.

Structure elements are accessed in the same way as other C-like
languages, using the `dot' operator: 

\vspace{12pt}
\spc \emph{variablename}{\cf .} \emph{fieldname}
\vspace{12pt}

Examples of declaration and use of structures:

\begin{code}
    struct ray {
        point pos;
        vector dir;
    };

    ray r;   // Declare a structure
    ray s = { point(0,0,0), vector(0,0,1), 1e6 };  // declare and initialize
    r.pos = point (1, 0, 0);  // Assign to one field
\end{code}

It is permitted to have a structure field that is an array, as well as
to have an array of structures.  But it is not permitted for one
structure to have a field that is another structure.

Please refer to Section~\ref{sec:types:struct} for more information
on using {\cf struct}.


\section{Expressions}
\label{sec:expressions}
\index{expressions}

The expressions available in \langname include the following:

\begin{itemize}
\item Constants: integer (e.g., {\cf 1}, {\cf 42}), floating-point
  (e.g. {\cf 1.0}, {\cf 3}, {\cf -2.35e4}), or string literals (e.g., {\cf
  "hello"})

\item point, vector, normal, or matrix constructors, for example:

\begin{code}
    color (1, 0.75, 0.5)
    point ("object", 1, 2, 3)
\end{code}

If all the arguments to a constructor are themselves constants, the
constructed point is treated like a constant and has no runtime cost.
That is, {\cf color(1,2,3)} is treated as a single constant entity, not
assembled bit by bit at runtime.

\item Variable or parameter references

\item An individual element of an array (using {\cf [ ] })

\item An individual component of a \color,
\point, \vector, \normal (using {\cf [ ]}), 
or of a \matrix (using {\cf [][]})

\item prefix and postfix increment and decrement operators:

\begin{tabbing}
\hspace{.25in} \= \hspace{2in} \= (negation) \kill \\
\> \emph{varref} {\cf ++} \hspace{1in} \= (post-increment) \\
\> \emph{varref} {\cf --}  \hspace{1in} \= (post-decrement) \\
\> {\cf ++} \emph{varref} \hspace{1in} \= (pre-increment) \\
\> {\cf --} \emph{varref} \hspace{1in} \= (pre-decrement) \\
\end{tabbing}

The post-increment and post-decrement (e.g., {\cf a++}) returns the old
value, then increments or decrements the variable; the pre-increment and
pre-decrement ({\cf ++a}) will first increment or decrement the
variable, then return the new value.

\item Unary and binary arithmetic operators on other expressions:

\begin{tabbing}
\hspace{0.25in} {\cf -} \emph{expr} \hspace{1in} \= (negation) \\
\hspace{0.25in} \verb|~| \emph{expr} \> (bitwise complement) \\
\hspace{0.25in} \emph{expr} {\cf *} \emph{expr} \> (multiplication) \\
\hspace{0.25in} \emph{expr} {\cf /} \emph{expr} \> (division) \\
\hspace{0.25in} \emph{expr} {\cf +} \emph{expr} \> (addition) \\
\hspace{0.25in} \emph{expr} {\cf -} \emph{expr} \> (subtraction) \\
\hspace{0.25in} \emph{expr} {\cf \%} \emph{expr} \> (integer modulus) \\
\hspace{0.25in} \emph{expr} {\cf <<} \emph{expr} \> (integer shift left) \\
\hspace{0.25in} \emph{expr} {\cf >>} \emph{expr} \> (integer shift right) \\
\hspace{0.25in} \emph{expr} {\cf \&} \emph{expr} \> (bitwise and) \\
\hspace{0.25in} \emph{expr} {\cf |} \emph{expr} \> (bitwise or) \\
\hspace{0.25in} \emph{expr} \verb|^| \emph{expr} \> (bitwise exclusive or) \\
\end{tabbing}

The operators {\cf +}, {\cf -}, {\cf *}, {\cf /}, and the unary {\cf -}
(negation) may be used on most of the numeric types.  For multicomponent
types (\color, \point, \vector, \normal, \matrix), these operators
combine their arguments on a component-by-component basis.
The only operators that may be applied to the \matrix type are
{\cf *} and {\cf /}, which respectively denote matrix-matrix
multiplication and matrix multiplication by the inverse of another
matrix.

The integer and bit-wise operators {\cf \%}, {\cf <<}, {\cf >>},
{\cf \&}, {\cf \verb|^|}, and {\cf |} may only be used with expressions
of type \inttype.

For details on which operators are allowed, please consult the operator
tables for each individual type in Chapter~\ref{chap:types}.

\item Relational operators (all lower precedence than the arithmetic
operators):

\begin{tabbing}
\hspace{0.25in} \emph{expr} {\cf ==} \emph{expr} \hspace{1in} \= (equal to) \\
\hspace{0.25in} \emph{expr} {\cf !=} \emph{expr} \> (not equal to) \\
\hspace{0.25in} \emph{expr} {\cf <} \emph{expr} \> (less then) \\
\hspace{0.25in} \emph{expr} {\cf <=} \emph{expr} \> (less than or equal to) \\
\hspace{0.25in} \emph{expr} {\cf >} \emph{expr} \> (greater than) \\
\hspace{0.25in} \emph{expr} {\cf >=} \emph{expr} \> (greater than or equal) \\
\end{tabbing}

The {\cf ==} and {\cf !=} operators may be performed between any two
values of equal type, and are performed component-by-component for
multi-component types.  The {\cf <}, {\cf <=}, {\cf >}, {\cf >=} may not
be used to compare multi-component types.

An \inttype expression may be compared to a \float (and is treated as if
they are both \float).  A \float expression may be compared to a
multi-component type (and is treated as a multi-component type as if
constructed from a single float).

Relation comparisons produce Boolean (true/false) values.  These
are implemented as \inttype values, 0 if false and 1 if true.

\item Logical unary and binary operators:

\hspace{0.5in}    {\cf !} \emph{expr}

\hspace{0.5in}  \emph{expr1} {\cf \&\&} \emph{expr2}

\hspace{0.5in}    \emph{expr1} {\cf ||} \emph{expr2}

\item another expression enclosed in parenthesis: {\cf ( )}.
  Parenthesis may be used to guarantee associativity of operations.

\item Type casts, specified either by having the type name in 
parentheses in front of the value to cast (C-style typecasts)
or the type name called as a constructor (C++-style type constructors):
\begin{code}
        (vector) P            /* cast a point to a vector */
        (point) f             /* cast a float to a point */
        (color) P             /* cast a point to a color! */

        vector (P)            /* Means the same thing */
        point (f)
        color (P)
\end{code}

The three-component types (\color, \point, \vector, \normal)
may be cast to other three-component types.  A \float
may be cast to any of the three-component types (by placing the
float in all three components) or to a {\cf matrix} (which makes a
matrix with all diagonal components being the {\cf float}).
Obviously, there are some type casts that are not allowed because
they make no sense, like casting a {\cf point} to a {\cf float}, or
casting a {\cf string} to a numerical type.

\item function calls

\item assignment expressions:
same thing as {\cf var = var OP expr} :

\begin{tabbing}
\hspace{0.25in} \emph{var} {\cf =} \emph{expr} \hspace{1in} \= (assign) \\
\hspace{0.25in} \emph{var} {\cf +=} \emph{expr} \> (add) \\
\hspace{0.25in} \emph{var} {\cf -=} \emph{expr} \> (subtract) \\
\hspace{0.25in} \emph{var} {\cf *=} \emph{expr} \> (multiply) \\
\hspace{0.25in} \emph{var} {\cf /=} \emph{expr} \> (divide) \\
\hspace{0.25in} \emph{int-var} {\cf \&=} \emph{int-expr} \> (bitwise and) \\
\hspace{0.25in} \emph{int-var} {\cf |=} \emph{int-expr} \> (bitwise or) \\
\hspace{0.25in} \emph{int-var} \verb|^=| \emph{int-expr} \> (bitwise
exclusive or) \\
\hspace{0.25in} \emph{int-var} {\cf <<=} \emph{int-expr} \> (integer
shift left) \\
\hspace{0.25in} \emph{int-var} {\cf >>=} \emph{int-expr} \> (integer
shift right) \\
\end{tabbing}

Note that the integer and bit-wise operators are only allowed with
\inttype variables and expressions.  In general, {\cf var OP= expr} is
allowed only if {\cf var = var OP expr} is allowed, and means exactly
the same thing.  Please consult the operator tables for each individual
type in Chapter~\ref{chap:types}.

\item ternary operator, just like C: 

\hspace{0.5in}  \emph{condition} {\cf ?} \emph{expr1} {\cf :} \emph{expr2}

This expression takes on the value of \emph{expr1} if \emph{condition}
is true (nonzero), or \emph{expr2} if \emph{condition} is false (zero).

\end{itemize}

Please refer to Chapter~\ref{chap:types}, where the section describing
each data type describes the full complement of operators that may be
used with the type.  Operator precedence in \langname is identical to
that of C.


\section{Control flow: {\cf if, while, do, for}}
\label{sec:controlflow}

Conditionals in \langname just like in C or C++:
\indexapi{if}

\begin{tabbing}
\hspace{0.5in} \= \hspace{0.3in} \= \kill
\> {\cf if (} \emph{condition} {\cf )} \\
\> \> \emph{truestatement}  
\end{tabbing}

\noindent and

\begin{tabbing}
\hspace{0.5in} \= \hspace{0.3in} \= \kill
\> {\cf if (} \emph{condition} {\cf )} \\
\> \> \emph{truestatement}  \\
\> {\cf else} \\
\> \> \emph{falsestatement}  
\end{tabbing}

\noindent The statements can also be entire blocks, surrounded by curly
braces.  For example,

\begin{code}
       if (s > 0.5) {
           x = s;
           y = 1;
       } else {
           x = s+t;
       }
\end{code}

\noindent The \emph{condition} may be any valid expression, including:

\begin{itemize}
\item The result of any comparison operator (such as {\cf <}, {\cf ==},
  etc.).
\item Any numeric expression (\inttype, \color, \point, \vector,
  \normal, \matrix), which is considered ``true'' if nonzero and
  ``false'' if zero.
\item Any string expression, which is considerd ``true'' if it is a
  nonempty string, ``false'' if it is the empty string (\qkw{}).
\item A logical combination of expressions using the operators {\cf !}
  (not), {\cf \&\&} (logical ``and''), or {\cf ||} (logical ``or'').
  Note that {\cf \&\&} and {\cf ||} \emph{short circuit} as in C,
  i.e. {\cf A \&\& B} will only evaluate B if A is true, and {\cf A ||
    B} will only evaluate B if A is false.
\end{itemize}

Repeated execution of statements for as long as a condition is true is
possible with a {\cf while} statement:
\indexapi{while}

\begin{tabbing}
\hspace{0.5in} \= \hspace{0.3in} \= \kill
\> {\cf while (} \emph{condition} {\cf )} \\
\> \> \emph{statement}  
\end{tabbing}

Or the test may happen after the body of the loop, with a {\cf do/while}
loop:
\indexapi{do/while}

\begin{tabbing}
\hspace{0.5in} \= \hspace{0.3in} \= \kill
\> {\cf do } \\
\> \> \emph{statement}  \\
\> {\cf while (} \emph{condition} {\cf );} \\
\end{tabbing}

\noindent Also, {\cf for} loops are also allowed:

\begin{tabbing}
\hspace{0.5in} \= \hspace{0.3in} \= \kill
\> {\cf for (} \emph{initialization-statement} {\cf ;} \emph{condition} {\cf ;} \emph{iteration-statement} {\cf )} \\
\> \> \emph{body}  
\end{tabbing}

\indexapi{for}
As in C++, a {\cf for} loop's initialization may contain variable
declarations and initializations, which are scoped locally to {\cf for}
loop itself.  For example,

\begin{code}
      for (int i = 0;  i < 3;  ++i) {
          ...
      }
\end{code}

As with {\cf if} statements, loop conditions may be relations or
numerical quantities (which are considered ``true'' if nonzero, 
``false'' if zero), or strings (considered ``true'' if nonempty,
``false'' if the empty string \qkw{}).

Inside the body of a loop, the {\cf break} statement terminates the loop
altogether, and the {\cf continue} statement skip to the end of the body
and proceeds to the next iteration of the loop.

\section{Functions}
\label{sec:syntax:functions}

\subsection{Function calls}
\label{sec:syntax:functioncalls}
\index{function calls}

Function calls are very similar to C and similar programming languages:

\begin{tabbing}
\hspace{0.5in} \= \hspace{0.3in} \= \kill
\> \emph{functionname} {\cf (} \emph{arg1} {\cf ,} ... {\cf ,} \emph{argn} {\cf )} \\
\end{tabbing}

If the function returns a value (not \void), you may use its value as
an expression.  It is fine to completely ignore the value of even
a non-\void function.

In \langname, all arguments are passed by reference.  This generally
will not be noticeably different from C-style ``pass by value''
semantics, except if you pass the same variable as two separate
arguments to a function that modifies an argument's value.

\subsection{Function definitions}
\index{function definitions}

function definitions

    return

\section{Lighting}
\label{sec:syntax:lighting}

    emit/illuminate

    lights/illuminance

trace, the hard way


\section{Global variables}
\label{sec:globalvars}
\index{global variables|(}

\emph{Global variables} (sometimes called \emph{graphics state
variables}) contain the basic information that the renderer knows
about the point being shaded, such as position, surface orientation, and
default surface color.  You need not declare these variables; they are
simply available by default in your shader.  Global variables available
in shaders are listed in Table~\ref{tab:globalvars}.

\begin{table}[H]
\begin{tabular}{|p{1.5in}p{4in}|} 
\hline
{\bf Variable} & {\bf Description} \\
\hline
\point\ {\ce P} & Position of the point you are shading.  In a
displacement shader, changing this variable displaces the surface. \\
\hline
\vector\ {\ce I} & The \emph{incident} ray direction, pointing from the
  viewing position to the shading position \P. \\
\hline
\normal\ {\ce N} & The surface ``sShading'' normal of the surface at
\P.  In a displacement shader, changing \N yields bump mapping. \\
\hline
\normal\ {\ce Ng} & The true surface normal at {\cf P}.  This can differ
  from {\cf N}; {\cf N} can be overridden in various ways including bump
  mapping and user-provided vertex normals, but {\cf Ng} is always the
  true surface normal of the facet you are shading.True geometric normal
  of the surface at \P. \\
\hline
\float\ {\ce u}, {\ce v} & The 2D parametric coordinates of \P (on the 
		  particular geometric primitive you are shading). \\
\hline
\vector\ {\ce dPdu}, {\ce dPdv} & Partial derivatives $\partial
P/\partial u$ and $\partial P/\partial v$ tangent to the surface at \P.  \\
\hline
\vector\ {\ce L} & Direction of incoming light (points from {\cf Ps} to
         {\cf Pl}). \\
\hline
\color\ {\ce Cl} & Incoming light color at P. \\
\hline
\point\ {\ce Ps} & Position at which the light is being queried (i.e., the
position passed to \illuminance). \\
\hline
\normal\ {\ce Ns} & Axis about which the light is being queried (i.e., the
axis passed to \illuminance), or the surface's \N if no axis was passed
to \illuminance). \\
\hline
\point\ {\ce Pl} & Position of the light source. \\
\hline
\normal\ {\ce Nl} & Normal on the light (area light sources only). \\[1ex]
\hline
\color\ {\ce C} & Incident ray color --- the color of the light leaving the surface from \P in the direction {\cf -I}. \\
\hline
\color\ {\ce opacity} & Incident ray opacity --- the degree to which the viewer can ``see through'' the surface at \P. \\[1ex]
\hline
\float\ {\ce time} & Current shutter time for the point being shaded. \\
\hline
\float\ {\ce dtime} & The amount of time covered by this shading sample. \\
\hline
\vector\ {\ce dPdtime} & How the surface position \P is moving per unit time.\\
\hline
\end{tabular}
\caption{Global variables available inside shaders.
\label{tab:globalvars}}
\end{table}



\begin{table}
\begin{tabular}{|p{1in}p{0.75in}p{0.75in}p{0.75in}p{1.7in}|}
\hline
{\bf Variable} & surface & displacement & volume & light \\
\hline
\P            & R     & RW & R     & R \\
\I            & R     &    & R$^1$ & R$^1$  \\
\N            & RW    & RW & R$^1$ & R$^1$ \\
{\cf Ng}      & R     & R  & R$^1$ & R$^1$ \\
{\cf dPdu}    & R     & R  & R$^1$ & R$^1$ \\
{\cf dPdv}    & R     & R  & R$^1$ & R$^1$ \\
{\cf u, v}    & R     & R  & R$^1$ & R$^1$ \\
{\cf L}       & R$^2$ &    & R$^2$ & RW \\
{\cf Cl}      & R$^2$ &    & R$^2$ & RW \\
{\cf Ps}      &       &    &       & R \\
{\cf Ns}      &       &    &       & R \\
{\cf Pl}      & R$^2$ &    & R$^2$ & R \\
{\cf Nl}      & R$^2$ &    & R$^2$ & R \\
{\cf C}       & RW    &    & RW    & \\
{\cf opacity} & RW    &    & RW    & \\
{\cf time}    & R     & R  & R     & R \\
{\cf dtime}   & R     & R  & R     & R \\
{\cf dPdtime} & R     & R  & R     & R \\
\hline 
\end{tabular}

$^1$Certain surface variables (including \N, \Ng, \I, etc.) are readable
in light or volume shaders, but in that case store the values for the
surface whose shading triggered execution of the shader.  Use caution:
light may be gathered from a completely different place (for example,
when stepping through a volume).

$^2$Light variables may be read in surface and volume shaders, but only
inside \illuminance loops, and they refer to the current light being
examined by the loop.

\caption{Accessibility of variables by shader type
\label{tab:globalvaraccess}}
\end{table}

\index{global variables|)}


\chapter{Standard Library Functions}
\label{chap:stdlibrary}

\def\floatcolorpoint{The \emph{type} may be any of \float, \color,
  \point, \vector, or \normal.  For \color and \point-like types, the
  computations are performed component-by-component (separately for $x$,
  $y$, and $z$).\xspace}

\section{Basic math functions}
\label{sec:stdlib:math}

\subsection{Mathematical constants}
\index{mathematical constants}

\langname defines several mathematical constants:

\medskip

\begin{tabular}{p{1in} p{3in}}
{\cf M\_PI}       & $\pi$ \\ \\
{\cf M\_PI\_2}    & $\pi/2$ \\ \\
{\cf M\_PI\_4}    & $\pi/4$ \\ \\
{\cf M\_E}        & $e$ \\ \\
{\cf M\_LN2}      & $\ln 2$ \\ \\
{\cf M\_LN10}     & $\ln 10$ \\ \\
{\cf M\_SQRT2}    & $\sqrt{2}$ \\ \\
{\cf M\_SQRT1\_2} & $\sqrt{1/2}$  \\ \\
\end{tabular}

\subsection{Mathematical functions}
\index{mathematical functions}
\index{functions!mathematical}

Most of these functions operate on a generic \emph{type} that my be any
of \float, \color, \point, \vector, or \normal.  For \color and
\point-like types, the computations are performed component-by-component
(separately for $x$, $y$, and $z$).

\medskip

\apiitem{\emph{type} {\ce radians} (\emph{type} deg) \\
\emph{type} {\ce degrees} (\emph{type} rad)}
\indexapi{radians()} \indexapi{degrees()}
Convert degrees to radians or radians to degrees.
\apiend

\index{trigonometry}
\index{functions!trigonometric}

\apiitem{\emph{type} {\ce cos} (\emph{type} x) \\
\emph{type} {\ce sin} (\emph{type} x) \\
\emph{type} {\ce tan} (\emph{type} x) }
\indexapi{cos()} \indexapi{sin()} \indexapi{tan()}
Computes the cosine, sine, and tangent of $x$ (measured in radians).
\apiend

\apiitem{\emph{type} {\ce acos} (\emph{type} x) \\
\emph{type} {\ce asin} (\emph{type} y) \\
\emph{type} {\ce atan} (\emph{type} y\_over\_x) \\
\emph{type} {\ce atan2} (\emph{type} y, \emph{type} x)}
\indexapi{acos()} \indexapi{asin()} \indexapi{atan()} \indexapi{atan2()}
Compute the principal value of the arc cosine, arc sine, and arc
For {\cf acos()} and {\cf asin()}, the value of the argument
will first be clamped to $[-1,1]$ to avoid invalid domain.

For {\cf acos()}, the result will always be in the range of $[0, \pi]$,
and for {\cf asin()} and {\cf atan()}, the result will always be in the
range of $[-\pi/2, \pi/2]$.  For {\cf atan2()}, the signs of both
arguments are used to determine the quadrant of the return value.
\apiend

\apiitem{\emph{type} {\ce cosh} (\emph{type} x) \\
\emph{type} {\ce sinh} (\emph{type} x) \\
\emph{type} {\ce tanh} (\emph{type} x) }
\indexapi{cosh()} \indexapi{sinh()} \indexapi{tanh()}
Computes the hyperbolic cosine, sine, and tangent of $x$ (measured in radians).
\apiend

\apiitem{\emph{type} {\ce pow} (\emph{type} x, \emph{type} y)}
\indexapi{pow()}
Computes $x^y$.  This function will return 0 for ``undefined''
operations, such as {\cf pow(-1,0.5)}.
\apiend

\apiitem{\emph{type} {\ce exp} (\emph{type} x) \\
\emph{type} {\ce exp2} (\emph{type} x) \\
\emph{type} {\ce expm1} (\emph{type} x)}
\indexapi{exp()} \indexapi{exp2()} \indexapi{expm1()}
Computes $e^x$, $2^x$, and $e^x-1$, respectively.  Note that 
{\cf expm1(x)} is accurate even for very small values of $x$.
\apiend

\apiitem{\emph{type} {\ce log} (\emph{type} x) \\
\emph{type} {\ce log2} (\emph{type} x) \\
\emph{type} {\ce log10} (\emph{type} x) \\
\emph{type} {\ce log} (\emph{type} x, \emph{type} b)}
\indexapi{log()} \indexapi{log2()} \indexapi{log10()}
Computes the logarithm of $x$ in base $e$, 2, 10, or arbitrary base $b$,
respectively.
\apiend

\apiitem{\emph{type} {\ce sqrt} (\emph{type} x) \\
\emph{type} {\ce inversesqrt} (\emph{type} x)}
\indexapi{sqrt()} \indexapi{inversesqrt()}
Computes $\sqrt{x}$ and $1/\sqrt{x}$.  Returns 0 if $x<0$.
\apiend

\apiitem{\emph{type} {\ce hypot} (\emph{type} x, \emph{type} y) \\
\emph{type} {\ce hypot} (\emph{type} x, \emph{type} y, \emph{type} x)}
\indexapi{hypot()}
Computes $\sqrt{x^2+y^2}$ and $\sqrt{x^2+y^2+z^z}$, respectively.
\apiend

\apiitem{\emph{type} {\ce abs} (\emph{type} x) \\
\emph{type} {\ce fabs} (\emph{type} x)} 
\indexapi{abs()} \indexapi{fabs()}
Absolute value of $x$.  (The two functions are synonyms.)
\apiend

\begin{annotate}
Should we fully return to C conventions, with abs() being for integers
and fabs being for float?  Or should abs() simply be overloaded, like
you'd do in C++ if we were starting from scratch today?
\end{annotate}

\apiitem{\emph{type} {\ce sign} (\emph{type} x)}
\indexapi{sign()}
Returns 1 if $x>0$, -1 if $x<0$, 0 if $x=0$.
\apiend

\apiitem{\emph{type} {\ce floor} (float x) \\
\emph{type} {\ce ceil} (\emph{type} x) \\
\emph{type} {\ce round} (\emph{type} x) \\
\emph{type} {\ce trunc} (\emph{type} x) }
\indexapi{floor()} \indexapi{ceil()} \indexapi{round()} \indexapi{trunc()}

Various rouinding methods: {\cf floor} returns the highest integer less
than or equal to $x$; {\cf ceil} returns the lowest integer greater than
or equal to $x$; {\cf round} returns the the closest integer to $x$, in
either direction; and {\cf trunc} returns the integer part of $x$
(equivalent to {\cf floor} if $x>0$ and {\cf ceil} if $x<0$).
\apiend

\apiitem{\emph{type} {\ce mod} (\emph{type} a, \emph{type} b) \\
\emph{type} {\ce fmod} (\emph{type} a, \emph{type} b)}
\indexapi{mod()}
\indexapi{fmod()}
Computes $a - b*\mbox{floor}(a/b)$.  The two functions are synonyms.
\apiend

\apiitem{\emph{type} {\ce min} (\emph{type} a, \emph{type} b) \\
\emph{type} {\ce max} (\emph{type} a, \emph{type} b) \\
\emph{type} {\ce clamp} (\emph{type} x, \emph{type} minval, \emph{type} maxval)}
\indexapi{min()} \indexapi{max()} \indexapi{clamp()}
The {\cf min()} and {\cf max()} functions return the minimum or maximum,
respectively, of a list of two or more values.  The {\cf clamp}
function returns

\hspace{2em} {\cf min(max(x,minval),maxval)},

\noindent that is, the value $x$ clamped to the specified range.
\apiend

\apiitem{\emph{type} {\ce mix} (\emph{type} x, \emph{type} y, float alpha)}
\indexapi{mix()}
The {\cf mix} function returns a linear blending :
$ x*(1-\alpha) + y*(\alpha) $
\apiend

\apiitem{float {\ce isnan} (float x) \\
float {\ce isinf} (float x) \\
float {\ce isfinite} (float x)}
\indexapi{isnan()} \indexapi{isinf()} \indexapi{isfinite()}
The {\cf isnan()} function returns 1 if $x$ is a not-a-number (NaN)
value, 0 otherwise.  The {\cf isinf()} function returns 1 if $x$ is an
infinite (Inf or --Inf) value, 0 otherwise.  The {\cf isfinite()}
function returns 1 if $x$ is an ordinary number (neither infinite nor
NaN), 0 otherwise.  \apiend

\begin{annotate}
Should these return int, like the C99 ones?
\end{annotate}

\apiitem{float {\ce erf} (float x) \\
float {\ce erfc} (float x)}
\indexapi{erf()} \indexapi{erfc()}
The {\cf erf()} function returns the error function 
${\mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2}} dt$.
The {\cf erfc} returns the complementary error function {\cf 1-erf(x)}
(useful in maintaining precision for large values of $x$).
\apiend

\section{Geometric functions}
\label{sec:stdlib:geom}
\index{geometric functions}
\index{functions!geometric}

\apiitem{\emph{ptype} {\ce ptype} (float f) \\
\emph{ptype} {\ce ptype} (float x, float y, float z)}
\indexapi{point()}
\indexapi{vector()}
\indexapi{normal()}

Constructs a point-like value (\emph{ptype} may be any of \point,
\vector, or \normal) from individual \float values.  If constructed
from a single \float, the value will be replicated for $x$, $y$, and $z$.

\apiend

\apiitem{\emph{ptype} {\ce ptype} (string space, f) \\
\emph{ptype} {\ce ptype} (string space, float x, float y, float z)}
\indexapi{point()} \indexapi{vector()} \indexapi{normal()}
Constructs a point-like value (\emph{ptype} may be any of \point,
\vector, or \normal) from individual \float coordinates, relative
to the named coordinate system.  In other words,
\begin{code}
    point (space, x, y, z)
\end{code}
\noindent is equivalent to
\begin{code}
    transform (space, "common", point(x,y,z))
\end{code}
(And similarly for \vector/\normal.)
\apiend

\apiitem{float {\ce dot} (vector A, vector B)}
\indexapi{dot()}
Returns the inner product of the two vectors (or normals), i.e., 
$A \cdot B = A_x B_x + A_y B_y + A_z C_z$.
\apiend

\apiitem{float {\ce cross} (vector A, vector B)}
\indexapi{cross()}
Returns the cross product of two vectors (or normals), i.e., 
$A \times B$.
\apiend

\apiitem{float {\ce length} (vector V) \\
float {\ce length} (normal V)}
\indexapi{length()}
Returns the length of a vector or normal.
\apiend

\apiitem{float {\ce distance} (point P0, point P1)}
\indexapi{distance()}
Returns the distance between two points.
\apiend

\apiitem{float {\ce distance} (point P0, point P1, point Q)}
\indexapi{distance()}
Returns the distance from {\cf Q} to the closest point on the line
segment joining {\cf P0} and {\cf P1}.

\begin{annotate}
\QUESTION In RMan this was called `ptlined'.  Do we like that better, or `distance'?
\end{annotate}
\apiend

\apiitem{vector {\ce normalize} (vector V) \\
vector {\ce normalize} (normal V)}
\indexapi{normalize()}
Return a vector in the same direction as $V$ but with length 1,
that is, {\cf V / length(V)} .
\apiend

\apiitem{vector {\ce faceforward} (vector N, vector I, vector Nref) \\
vector {\ce faceforward} (vector N, vector I)}
\indexapi{faceforward()}
If {\cf dot (Nref, I)} $<0$, returns {\cf N}, otherwise returns {\cf -N}.
For the version with only two arguments, {\cf Nref} is implicitly {\cf
Ng}, the true surface normal.  The point of these routines is to
return a version of {\cf N} that faces towards the camera --- in the
direction ``opposite'' of {\cf I}.

To further clarify the situation, here is the implementation of
{\cf faceforward} expressed in \langname:

\begin{code}
vector faceforward (vector N, vector I, vector Nref)
{
    return (I.Nref > 0) ? -N : N;
}

vector faceforward (vector N, vector I)
{
    return faceforward (N, I, Ng);
}
\end{code}
\apiend

\apiitem{vector {\ce reflect} (vector I, vector N)}
\indexapi{reflect()}
For incident vector {\cf I} and surface orientation {\cf N}, returns the
reflection direction {\cf R = I - 2*(N.I)*N}.  Note that {\cf N} must be
normalized (unit length) for this formula to work properly.
\apiend

\apiitem{vector {\ce refract} (vector I, vector N, float eta)}
\indexapi{refract()}
For incident vector {\cf I} and surface orientation {\cf N}, 
returns the refraction direction using Snell's law. The {\cf eta} 
parameter is the ratio of the index of refraction of the volume containing
{\cf I} divided by the index of refraction of the volume being entered.
\apiend

\apiitem {void {\ce fresnel} (vector I, normal N, float eta, \\
 \mbox{\hspace{1in}}   output float Kr, output float Kt,  \\
 \mbox{\hspace{1in}}   output vector R, output float T); }
\indexapi{fresnel()}
According to Snell's law and the Fresnel equations, {\cf fresnel}
computes the reflection and transmission direction vectors {\cf R} and
{\cf T}, respectively, as well as the scaling factors for reflected
and transmitted light, {\cf Kr} and {\cf Kt}.  The {\cf I} parameter
is the normalized incident ray, {\cf N} is the normalized surface normal,
and {\cf eta} is the ratio of refractive index of the medium
containing {\cf I} to that on the opposite side of the surface.
\apiend

\apiitem{point {\ce rotate} (point Q, float angle, point P0, point P1)}
\indexapi{rotate()}
Returns the point computed by rotating point {\cf Q} by {\cf angle} 
radians about the axis that passes from point {\cf P0} to {\cf P1}.
\apiend

\apiitem{\emph{ptype} {\ce transform} (string tospace, \emph{ptype} p) \\
\emph{ptype} {\ce transform} (string fromspace, string tospace, \emph{ptype} p) \\
\emph{ptype} {\ce transform} (matrix Mto, \emph{ptype} p)}
\indexapi{transform()}

Transform a \point, \vector, or \normal (depending on the type of the
\emph{ptype p} argument) from the coordinate system named by
\emph{fromspace} to the one named by \emph{tospace}.  If 
\emph{fromspace} is not supplied, $p$ is assumed to be in \commonspace
coordinates, so the transformation will be from \commonspace to
\emph{tospace}.  A $4 \times 4$ matrix may be passed directly rather
than specifying coordinate systems by name.

Depending on the type of the passed point $p$, different transformation
semantics will be used.  A \point will transform as a position, a
\vector as a direction without regard to positioning, and a \normal will
transform subtly differently than a \vector in order to preserve
orthogonality to the surface under nonlinear
scaling.\footnote{Technically, what happens is this: The \emph{from} and
  \emph{to} spaces determine a $4 \times 4$ matrix.  A \point $(x,y,z)$
  will transform the 4-vector $(x,y,z,1)$ by the matrix; a \vector will
  transform $(x,y,z,0)$ by the matrix; a \normal will transform
  $(x,y,z,0)$ by the inverse of the transpose of the matrix.}

\apiend


\apiitem{float {\ce transformu} (string tounits, float x) \\
float {\ce transformu} (string fromunits, string tounits, float x)}
\indexapi{transformu()}
\index{units}

Transform a measurement from \emph{fromunits} to \emph{tounits}.  If
\emph{fromunits} is not supplied, $x$ will be assumed to be in
\commonspace units.

For length conversions, unit names may be any of: \qkw{mm}, \qkw{cm},
\qkw{m}, \qkw{km}, \qkw{in}, \qkw{ft}, \qkw{mi}, or the name of any
coordinate system, including \qkw{common}, \qkw{world}, \qkw{shader}, or
any other named coordinate system that the renderer knows about.

For time conversions, units may be any of: \qkw{s}, \qkw{frames}, or
\qkw{common} (which indicates whatever timing units the renderer is
using).

It is only valid to convert length units to other length units, or time
units to other time units.  Attempts to convert length to time or vice
versa will result in an error.  Don't even think about trying to convert
monetary units to time.
\apiend



\section{Color functions}
\label{sec:stdlib:color}
\index{color functions}
\index{functions!color}

\apiitem{color {\ce color} (float f) \\
color {\ce color} (float r, float g, float b)}
\indexapi{color()}
Constructs a \color from individual \float values.  If constructed
from a single \float, the value will be replicated for $r$, $g$, and $b$.
\apiend

\apiitem{color {\ce color} (string colorspace, f) \\
color {\ce color} (string colorspace, float r, float g, float b)}
\indexapi{color()}
Constructs an RGB \color that is equivalent to the individual \float values in a
named color space.  In other words,
\begin{code}
    color (colorspace, r, g, b)
\end{code}
\noindent is equivalent to
\begin{code}
    transformc (colorspace, "rgb", color(r, g, b))
\end{code}
\apiend

\apiitem{float {\ce luminance} (color rgb)}
\indexapi{luminance()}
Returns the linear luminance of the color \emph{rgb}, which is
implemented per the ITU-R standard as $0.2126 R + 0.7152 G + 0.0722 B$.
\apiend

\apiitem{color {\ce transformc} (string fromspace, string tospace, color Cfrom)\\
color {\ce transformc} (string tospace, color Cfrom)}
\indexapi{transformc()}
Transforms color \emph{Cfrom} from color space \emph{fromspace} to
color space \emph{tospace}.  If \emph{fromspace} is not supplied,
it is assumed to be transforming from \rgbspace.

\begin{annotate}
\QUESTION Should this be renamed `ctransform' to match RMan?
\end{annotate}
\apiend


\section{Matrix functions}
\label{sec:stdlib:matrix}
\index{matrix functions}
\index{functions!matrix}

\apiitem{matrix {\ce matrix} (float m00, float m01, float m02, float  m03, \\
\bigspc\spc float m10, float m11, float m12, float m13, \\
\bigspc\spc float m20, float m21, float m22, float m23, \\
\bigspc\spc float m30, float m31, float m32, float m33)}
\indexapi{matrix()}
Constructs a \matrix from 16 individual \float values, in row-major
order.  
\apiend

\apiitem{matrix {\ce matrix} (float f)}
\indexapi{matrix()}
Constructs a \matrix with $f$ in all diagonal components, 0 in all other
components.  In other words, {\cf matrix(1)} is the identity matrix, and
{\cf matrix(f)} is {\cf f*matrix(1)}.
\apiend

\apiitem{matrix {\ce matrix} (string fromspace, float m00, ..., float m33) \\
matrix {\ce matrix} (string fromspace, float f)}
\indexapi{matrix()}
Constructs a \matrix relative to the named space, multiplying it by the
{\cf space}-to-{\cf common} transformation matrix.  

Note that {\cf matrix (space, 1)} returns the 
\emph{space}-to-{\cf common} transformation matrix.
\apiend

\apiitem{float {\ce determinant} (matrix M)}
\indexapi{determinant()}
Computes the determinant of matrix $M$.
\apiend

\apiitem{matrix {\ce transpose} (matrix M)}
\indexapi{transpose()}
Computes the transpose of matrix $M$.
\apiend


\begin{comment}
translate
rotate
scale
\end{comment}


\section{Pattern generation}
\label{sec:stdlib:pattern}
\index{pattern generation functions}
\index{functions!pattern generation}

\apiitem{float {\ce step} (float edge, float x)}
\indexapi{step()}
Returns 0 if $x < {\mathit edge}$ and 1 if $x \ge {\mathit edge}$.
\apiend

\apiitem{float {\ce smoothstep} (float edge0, float edge1, float x)}
\indexapi{smoothstep()}
Returns 0 if $x \le {\mathit edge0}$, and 1 if $x \ge {\mathit edge1}$,
and performs a smooth Hermite
interpolation between 0 and 1 when ${\mathit edge0} < x < {\mathit edge1}$.
This is useful in cases where you would want a thresholding function
with a smooth transition.
\apiend

%\section{Noise functions}
%\label{sec:stdlib:noise}
%
%Noise functions (sometimes called ``Perlin noise'')

\apiitem{\emph{type} {\ce noise} (float u) \\
\emph{type} {\ce noise} (float u, float v) \\
\emph{type} {\ce noise} (point p) \\
\emph{type} {\ce noise} (point p, float t)}
\indexapi{noise()}

Returns a continuous, pseudo-random (but repeatable) scalar field
defined on a domain of dimension 1 (\float), 2 (2 \float's), 3 (\point),
or 4 (\point and \float).

The range of \noise is $[0,1]$, its large-scale average is 0.5, it is 
fairly isotropic and nonperiodic (or at least has an extremely large
period), and mostly band-limited to frequences between 0.5 and 1.0.
This makes it ideal to use as a basis function for pattern generation.

The return \emph{type} may be any of \float, \color, \point, \vector, or
\normal, depending on the type of the variable the result is assigned to
(or based on an explicit type cast).  For multi-component return types
(e.g., \point), each component is an uncorrelated \float \noise
function.
\apiend

\apiitem{\emph{type} {\ce snoise} (float u) \\
\emph{type} {\ce snoise} (float u, float v) \\
\emph{type} {\ce snoise} (point p) \\
\emph{type} {\ce snoise} (point p, float t)}
\indexapi{snoise()}
The \snoise function (\emph{signed} noise) is just like
\noise, but scaled so that its range is $[-1,1]$ and its large-scale
average is 0.
\apiend

\apiitem{\emph{type} {\ce pnoise} (float u, float uperiod) \\
\emph{type} {\ce pnoise} (float u, float v, float uperiod, float vperiod) \\
\emph{type} {\ce pnoise} (point p, point pperiod) \\
\emph{type} {\ce pnoise} (point p, float t, point pperiod, float tperiod) 
\smallskip \\
\emph{type} {\ce psnoise} (float u, float uperiod) \\
\emph{type} {\ce psnoise} (float u, float v, float uperiod, float vperiod) \\
\emph{type} {\ce psnoise} (point p, point pperiod) \\
\emph{type} {\ce psnoise} (point p, float t, point pperiod, float tperiod)}
\indexapi{pnoise()}
\indexapi{psnoise()}
The \pnoise function is just like \noise, but is periodic with the given
period.  In other words, {\cf pnoise(x,period) == pnoise(x+period,period)}.
Periods are only meaningful if they are positive integers, so actually
the period is rounded down to the nearest integer, and clamped to a
minimum of 1.

The \psnoise function a signed version of \pnoise, i.e., identical to
\pnoise but having a range of $[-1,1]$ and average value of 0.
\apiend

\apiitem{\emph{type} {\ce cellnoise} (float u) \\
\emph{type} {\ce cellnoise} (float u, float v) \\
\emph{type} {\ce cellnoise} (point p) \\
\emph{type} {\ce cellnoise} (point p, float t)}
\indexapi{cellnoise()}
Returns a discrete pseudo-random (but repeatable) scalar field
defined on a domain of dimension 1 (\float), 2 (2 \float's), 3 (\point),
or 4 (\point and \float).  

The \cellnoise function is constant on $[i,i+1)$ for all
integers $i$, in other words, {\cf cellnoise(x) == cellnoise(floor(x))},
but has a different and uncorrelated value at every integer.  The range
is $[0,1]$, its large-scale average is 0.5, and its values are evenly
distributed over $[0,1]$.

The return \emph{type} may be any of \float, \color, \point, \vector, or
\normal, depending on the type of the variable the result is assigned to
(or based on an explicit type cast).  For multi-component return types
(e.g., \point), each component is an uncorrelated \float \cellnoise
function.
\apiend

\apiitem{\emph{type} {\ce hash} (float u) \\
\emph{type} {\ce hash} (float u, float v) \\
\emph{type} {\ce hash} (point p) \\
\emph{type} {\ce hash} (point p, float t)}
\indexapi{hash()}
Returns a deterministic, repeatable \emph{hash} of the 1-, 2-, 3-, or
4-D coordinates.  The return values will be evenly distributed on
$[0,1]$ and be be completely repeatable when passed the same coordinates
again, yet will be uncorrellated to hashes of any other positions
(including nearby points).  This is like having a random value indexed
spatially, but that will be repeatable from frame to frame of an
animation (provided its input is \emph{precisely} identical).

The return \emph{type} may be any of \float, \color, \point, \vector, or
\normal, depending on the type of the variable the result is assigned to
(or based on an explicit type cast).  For multi-component return types
(e.g., \point), each component is an uncorrelated \float {\cf hash}
function.
\apiend

\apiitem{\emph{type} {\ce random} ()}
\indexapi{random()}
Returns a pseudorandom value uniformly distributed on $[0,1]$.  Use with
extreme caution --- the results are not necessarily repeatable from
frame to frame.

The return \emph{type} may be any of \float, \color, \point, \vector, or
\normal, depending on the type of the variable the result is assigned to
(or based on an explicit type cast).  For multi-component return types
(e.g., \point), each component is an uncorrelated \float {\cf random()}
function.
\apiend

\apiitem{\emph{type} {\ce spline} (string basis, float x, \emph{type} $\mathtt{y}_0$, \emph{type} $\mathtt{y}_1$, ... \emph{type} $\mathtt{y}_{n-1}$)\\
\emph{type} {\ce spline} (string basis, float x, \emph{type} y[])}
\indexapi{spline()}

As $x$ varies from 0 to 1, {\cf spline} returns the value of a cubic
interpolation of uniformly-spaced knots $y_0$...$y_{n-1}$, or
$y[0]$...$y[n-1]$ for the array version of the call (where $n$ is the
length of the array).  The input value $x$ will be clamped to lie
on $[0,1]$.  The \emph{type} may be any of \float, \color,
\point, \vector, or \normal; for multi-component types (e.g. \color),
each component will be interpolated separately.

The type of interpolation is specified by the \emph{basis} name,
\emph{basis} parameter, which may be any of: \qkw{catmull-rom},
\qkw{bezier}, \qkw{bspline}, \qkw{hermite}, or \qkw{linear}.  Some basis
types require particular numbers of knot values -- Bezier splines
require $4n+3$ values, Hermite splines require $4n+2$ values,
Catmull-Rom and linear splines may use any number of values $n\ge 4$.
To maintain consistency with the other spline types, linear splines will
ignore the first and last data value, interpolating piecewise-linearly
between $y_1$ and $y_{n-2}$.
\apiend

\apiitem{float {\ce inversespline} (string basis, float v, float $\mathtt{y}_0$, ... float $\mathtt{y}_{n-1}$)\\
float {\ce inversespline} (string basis, float v, float y[])}
\indexapi{inversespline()}

Computes the \emph{inverse} of the {\cf spline()} function --- i.e., returns
the value $x$ for which {\cf spline (basis, x, y...)} would return value
$v$.  Results are undefined if the knots do not specifiy a monotonic
(only increasing or only decreasing) spline.
\apiend



\section{Derivatives and area operators}
\label{sec:stdlib:derivs}
\index{derivative functions}
\index{functions!derivatives and area}
\index{derivatives}

\apiitem{float {\ce deltau} (float x), {\ce deltav} (float x) \\
vector {\ce deltau} (point x), {\ce deltav} (point x) \\
vector {\ce deltau} (vector x), {\ce deltav} (vector x)\\
color {\ce deltau} (color x), {\ce deltav} (color x)}
\indexapi{deltau()} \indexapi{deltav()}
Compute differentials of the argument $x$, i.e., the approximate change
in $x$ between adjacent shading samples in each of two principal
directions.  Depending on the renderer implementation, those directions
may be $x$ and $y$ on the imaging plane, may be parametric $u$ and $v$
on the surface, or something else.  Do not confuse the ``u'' and ``v''
in the name with a guarantee that it is tied to the surface parameters.
\apiend

\apiitem{float {\ce Du} (float x), {\ce Dv} (float x) \\
vector {\ce Du} (point x), {\ce Dv} (point x) \\
vector {\ce Du} (vector x), {\ce Dv} (vector x)\\
color {\ce Du} (color x), {\ce Dv} (color x)}
\indexapi{Du()} \indexapi{Dv()}
Compute an approximation to the derivatives of $x$ with respect to
each of two principal directions.  Depending on the renderer
implementation, those directions may be $x$ and $y$ on the imaging
plane, may be parametric $u$ and $v$ on the surface, or something else.
Do not confuse the ``u'' and ``v'' in the name with a guarantee that it
is tied to the surface parameters.
\apiend

\begin{annotate}
\QUESTION I'm uncomfortable with these definitions.  Does this make
sense at all in a renderer-agnostic way?  Is it horribly confusing to
call it ``u'' and ``v'' in a ray tracer that's probably computing
derivatives with respect to screen x and y?  If we called it deltax,
deltay, Dx, Dy, would that be confusing in a renderer that really was
Reyes-like and shading in parameter space?

For that matter, is there any legitimate use for differentials or
derivatives along the principal directions, or is the only really
useful quantity filterwidth()?
\end{annotate}

\apiitem{float {\ce filterwidth} (float x) \\
vector {\ce filterwidth} (point x) \\
vector {\ce filterwidth} (vector x)}
\indexapi{filterwidth()}
Compute differentials of the argument $x$, i.e., the approximate change
in $x$ between adjacent shading samples.
\apiend


\apiitem{float {\ce area} (point p)}
\indexapi{area()}
Returns the differential area of position $p$ corresponding to this
shading sample.  If $p$ is the actual surface position \P, then 
{\ce area(P)} will return the surface area of the section of the
surface that is ``covered'' by this shading sample.
\apiend

\apiitem{vector {\ce calculatenormal} (point p)}
\indexapi{calculatenormal()}
Returns a vector perpendicular to the surface that is defined by point
$p$ (as $p$ is computed at all points on the currently-shading surface),
taking into account surface orientation.
\apiend

\apiitem{float {\ce aastep} (float edge, float s) \\
float {\ce aastep} (float edge, float s, float ds) \\
float {\ce aastep} (float edge, float s, float dedge, float ds)
\smallskip \\
float {\ce aastep} (float edge, float s, string filter) \\
float {\ce aastep} (float edge, float s, float ds, string filter) \\
float {\ce aastep} (float edge, float s, float dedge, float ds, string filter)}
\indexapi{aastep()}
Computes an antialiased step function, similar to {\cf step(edge,s)} but
filtering the edge to take into account how rapidly {\cf s} and {\cf edge}
are changing over the surface.  If the differentials {\cf ds} and/or
{\cf dedge} are not passed explicitly, they will be automatically 
computed (using {\cf aastep()}).

The optional {\cf filter} parameter specifies which filter should be
used: \qkw{catmull-rom}, \qkw{box}, \qkw{triangle}, or \qkw{gaussian}.
If no {\cf filter} parameter is supplied, a Catmull-Rom filter will be
used.

\begin{annotate}
\QUESTION This is similar to RenderMan's ``filterstep'', but not quite.
Is it better to call it ``filterstep'' even if it doesn't exactly match,
or should we stick to the changed name to match the changed functionality?
\end{annotate}
\apiend


\section{Displacement functions}
\label{sec:stdlib:displace}
\index{displacement}
\index{bump mapping}
\index{functions!displacement}

\apiitem{void {\ce displace} (float amp) \\
void {\ce displace} (string space, float amp) \\
void {\ce displace} (vector offset)}
\indexapi{displace()}

Displace the surface in the direction of the shading normal \N by
\emph{amp} units as measured in the named \emph{space} (or \currentspace
if none is specified).  Alternately, the surface may be moved by a fully
general \emph{offset}, which does not need to be in the direction of the
surface normal.

In either case, this function both displaces the surface and adjusts the
shading normal \N to be the new surface normal of the displaced surface
(properly handling both continuously smooth surfaces as well as
interpolated normals on faceted geometry, without introducing faceting
artifacts).
\apiend

\apiitem{void {\ce bump} (float amp) \\
void {\ce bump} (string space, float amp) \\
void {\ce bump} (vector offset)}
\indexapi{bump()}

Adjust the shading normal \N to be the surface normal as if the
surface had been displaced by the given amount (see the {\cf displace()}
function description), but without actually moving the surface
positions.
\apiend


\section{String functions}
\label{sec:stdlib:string}
\index{string functions}
\index{functions!string}

\apiitem{void {\ce printf} (string fmt, ...)}
\indexapi{printf()}

Much as in C, {\cf printf()} takes a format string {\cf fmt} and an argument list, and
prints the resulting formatted string to the console.  

Where the
fmt contains the characters {\cf \%f}, {\cf \%c}, {\cf \%p}, {\cf
\%m}, and {\cf \%s}, {\cf printf} will substitute arguments, in order,
from the argument list (assuming that the argument types are \float,
\color, point-like, \matrix, and {\cf string}, respectively).  In addition,
{\cf \%d} and {\cf \%i} will also print \float's, truncating and
printing them as if they were integers.
\apiend

\apiitem{string {\ce format} (string fmt, ...)}
\indexapi{format()}
The {\cf format} function works similarly to {\cf printf}, except that
instead of printing the results, it returns the formatted text as a
\string.
\apiend

\apiitem{void {\ce error} (string fmt, ...)}
\indexapi{error()}
The {\cf error()} function works similarly to {\cf printf}, but the
results will be printed as a renderer error message, possibly including
information about the name of the shader and the object being shaded,
and other diagnostic information.
\apiend

\apiitem{void {\ce fprintf} (string filename, string fmt, ...)}
\indexapi{fprintf()}
The {\cf fprintf()} function works similarly to {\cf printf}, but rather
than printing to the default text output stream, the results will be
concatentated onto the end of the text file named by {\cf filename}.
\apiend

\apiitem{string {\ce concat} (string s1, ..., string sN)}
\indexapi{concat()}
Concatenates a list of strings, returning the aggregate string.
\apiend

\begin{annotate}
I'm still gathering requirements for regular expression matching
functions.
\end{annotate}

\apiitem{int {\ce regex_match} (string subject, string regex)}
\indexapi{match()}
Returns 1 if the entire string \emph{subject} matches a standard POSIX 
regular expression \emph{regex}, 0 if it does not.
\apiend

\apiitem{string {\ce substr} (string s, int start, int length)\\
string {\ce substr} (string s, int start)}
\indexapi{substr()}
Return at most \emph{length} characters from \emph{s}, starting with the
character indexed by \emph{start} (beginning with 0).  If \emph{length}
is omitted, return the rest of \emph{s}, starting with \emph{start}.  If
\emph{start} is negative, it counts backwards from the end of the string
(for example, {\cf substr(s,-1)} returns just the last character of
\emph{s}).
\apiend


\begin{annotate}
Should we look at Pystring and add useful things here?
\end{annotate}


\section{Texture}
\label{sec:stdlib:texture}
\index{texture functions}
\index{functions!texture}
\index{texture mapping}

FIXME
texture
texture3d
spatialdbsave
spatialdbquery

\section{Light and Shadows}
\label{sec:stdlib:light}
\index{light and shadow functions}
\index{functions!light and shadows}

FIXME
environment
shadow
ambient
diffuse
specular
specularbrdf
indirect
occlusion
subsurface


\section{Renderer state and message passing}
\label{sec:stdlib:state}
\index{functions!renderer state}
\index{message passing}

FIXME
getattribute
setmessage
getmessage
gettextureinfo

\apiitem{int {\ce raylevel} ()}
\indexapi{raylevel()}
Returns the \emph{ray level} of the current shading sample --- {\cf 0}
if the surface is viewed directly by the camera, {\cf 1} if it is a
first-level reflection or refraction, {\cf 2} if it is a
reflection/refraction visible in a reflection/refraction, etc.
\apiend

\apiitem{int {\ce isshadowray} ()}
\indexapi{isshadowray()}
Returns {\cf 1} if the shader is executing for the sole purpose of
determining the object's opacity (typically for a shadow), in which case
it may be prudent for the shader to avoid computations that are only
needed to determine the surface color or other outputs.  This function
returns {\cf 0} (indicating that the surface should be computing surface
color, opacity, and all its other outputs).
\apiend

\apiitem{int {\ce isindirectray} ()}
\indexapi{isindirectray()}
Returns {\cf 1} if the shader is executing for the sole purpose of
determining the object's appearance for an indirect (or global
illumination) sample and therefore will not be seen distinctly in the
final image, in which case it may be prudent for the shader to take
shortcuts or avoid computing fine detail.  This function returns {\cf 0}
if it is being run for ordinary visibility rays, in which case the
results may be clearly seen and all details should be computed.
\apiend


\section{Miscellaneous}
\label{sec:stdlib:misc}

\apiitem{int {\ce arraylength} (\emph{type} A[])}
\indexapi{arraylength()}
Returns the length of the referenced array, which may be of any type.
\apiend

\apiitem{void {\ce exit} ()}
\indexapi{exit()}
Exits the shader without further execution.  Within the main body of a
shader, this is equivalent to calling {\cf return}, but inside a
function, {\cf exit()} will exit the entire shader, whereas {\cf return}
would only exit the enclosing function.
\apiend



\index{standard library functions|(}   % end of chapter

\chapter{Formal Language Syntax}
\label{chap:formalsyntax}

FIXME

BNF

keywords

reserved words






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Appendices}
\begin{appendix}

%\include{typedesc}
%\chapter{Building Unnamed Shading Language}

%\include{header}
%\include{glossary}
\end{appendix}

\backmatter

%\bibliographystyle{alpha}	%% Select for [FB95]
\bibliographystyle{apalike}    %% Select for (Foo and Bar, 1995)
%\addcontentsline{toc}{chapter}{Bibliography}
%\bibliography{mybib}

\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}


% Canonical figure
%\begin{figure}[ht]
%\noindent
%\includegraphics[width=5in]{Figures/bredow/foo} 
%\caption{Caption
%\label{fig:foo}}
%\end{figure}
