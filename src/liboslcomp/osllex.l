/** Lexical scanner for Sony Imageworks Shading Language
 **/

/*****************************************************************************
 *
 *             Copyright (c) 2009 Sony Pictures Imageworks, Inc.
 *                            All rights reserved.
 *
 *  This material contains the confidential and proprietary information
 *  of Sony Pictures Imageworks, Inc. and may not be disclosed, copied or
 *  duplicated in any form, electronic or hardcopy, in whole or in part,
 *  without the express prior written consent of Sony Pictures Imageworks,
 *  Inc. This copyright notice does not imply publication.
 *
 *****************************************************************************/


/************************************************************
 * Definitions section
 ************************************************************/


/* Option 'noyywrap' indicates that when EOF is hit, yyin does not 
 * automatically reset to another file.
 */
%option noyywrap

 /* Option 'prefix' creates a C++ lexer with the given prefix, so that
  * we can link with other flex-generated lexers in the same application
  * without name conflicts.
  */
%option prefix="osl"


 /* Define regular expression macros 
  ************************************************/

 /* white space, not counting newline */
WHITE           [ \t\v\f\r]+
 /* alpha character */
ALPHA           [A-Za-z]
 /* numerals */
DIGIT           [0-9]
 /* Integer literal */
INTEGER         {DIGIT}+
 /* floating point literal (FLT1 and FLT2 are just helpers) */
FLT1            X[-+]?{DIGIT}+\.?([eE][-+]?{DIGIT}+)?
FLT2            X[-+]?{DIGIT}*\.{DIGIT}+([eE][-+]?{DIGIT}+)?
FLT             {FLT1}|{FLT2}
 /* string literal */
STR     \"(\\.|[^\\"])*\"
STRDUMMY \"(\\.|[^\\"])*\"
 /* Dumb note: STRDUMMY is just to fix my syntax highlighting in emacs,
  * which is thrown off by the odd number of quotes!
  */
 /* Identifier: alphanumeric, may contain '_' after the first character */
IDENT           ({ALPHA}|[_])({ALPHA}|{DIGIT}|[_])*
 /* C preprocessor (cpp) directives */
CPP             ^[ \t]*#.*\n
CPLUSCOMMENT    \/\/.*\n



 /* Note for lex newbies: the following '%{ .. %}' section contains literal
  * C code that will be inserted at the top of code that flex generates.
  */
%{
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <string>

#include "oslcomp_pvt.h"
using namespace OSL::pvt;

#include "oslgram.hpp"   /* Generated by bison/yacc */

#define yylval osllval

void preprocess (const char *yytext);

%}


%%

 /************************************************
  * Lexical matching rules
  ************************************************/

 /* preprocessor symbols */
{CPP}	 	        {  preprocess (YYText()); }

 /* Comments */
{CPLUSCOMMENT}          {  oslcompiler->incr_lineno(); /* skip it */ }

 /* keywords */
"break"			{  return (yylval.i=BREAK); }
"closure"		{  return (yylval.i=CLOSURE); }
"color"			{  return (yylval.i=COLOR); }
"continue"		{  return (yylval.i=CONTINUE); }
"do"		        {  return (yylval.i=DO); }
"else"			{  return (yylval.i=ELSE); }
"float"			{  return (yylval.i=FLOAT); }
"for"			{  return (yylval.i=FOR); }
"if"			{  return (yylval.i=IF); }
"illuminance"	        {  return (yylval.i=ILLUMINANCE); }
"illuminate"	        {  return (yylval.i=ILLUMINATE); }
"int"		        {  return (yylval.i=INT); }
"matrix"		{  return (yylval.i=MATRIX); }
"normal"		{  return (yylval.i=NORMAL); }
"output"                {  return (yylval.i=OUTPUT); }
"point"			{  return (yylval.i=POINT); }
"public"		{  return (yylval.i=PUBLIC); }
"return"		{  return (yylval.i=RETURN); }
"string"		{  return (yylval.i=STRING); }
"struct"		{  return (yylval.i=STRUCT); }
"vector"		{  return (yylval.i=VECTOR); }
"void"			{  return (yylval.i=VOID); }
"while"			{  return (yylval.i=WHILE); }

 /* reserved words */
"bool"|"case"|"char"|"class"|"const"|"default"|"double" |    \
"enum"|"extern"|"false"|"friend"|"inline"|"long"|"private" | \
"protected"|"short"|"signed"|"sizeof"|"static"|"struct" |    \
"switch"|"template"|"this"|"true"|"typedef"|"uniform" |      \
"union"|"unsigned"|"varying"|"virtual" {
                            fprintf (stderr, "Error: \"%s\", line %d:\n"
                                     "\t'%s' is a reserved word\n",
                                     oslcompiler->filename().c_str(),
                                     oslcompiler->lineno(), YYText());
                            return (yylval.i=RESERVED);
                        }


 /* Identifiers */
{IDENT}	                {
                            yylval.s = ustring(YYText()).c_str();
                            return IDENTIFIER;
                        }

 /* Literal values */
{INTEGER}               {
                            yylval.i = atoi (YYText());
                            return INT_LITERAL;
                        }

{FLT}                   {
                            yylval.f = atof (YYText());
                            return FLOAT_LITERAL;
                        }

{STR}                   {
                            // grab the material between the quotes
                            ustring s (YYText(), 1, strlen(YYText())-2);
                            yylval.s = s.c_str();
                            return STRING_LITERAL;
                        }

 /* The one-char operators (like "+") will return correctly with the
  * catch-all rule, but we need to define the two-character operators
  * so they are not lexed as '+' and '=' separately, for example.
  */
"+="			{  return (yylval.i=ADD_ASSIGN); }
"-="			{  return (yylval.i=SUB_ASSIGN); }
"*="			{  return (yylval.i=MUL_ASSIGN); }
"/="			{  return (yylval.i=DIV_ASSIGN); }
"&="			{  return (yylval.i=BIT_AND_ASSIGN); }
"|="			{  return (yylval.i=BIT_OR_ASSIGN); }
"^="			{  return (yylval.i=BIT_XOR_ASSIGN); }
"<<="			{  return (yylval.i=SHL_ASSIGN); }
">>="			{  return (yylval.i=SHR_ASSIGN); }
"<<"			{  return (yylval.i=SHL_OP); }
">>"			{  return (yylval.i=SHR_OP); }
"&&"			{  return (yylval.i=LOGIC_AND_OP); }
"||"			{  return (yylval.i=LOGIC_OR_OP); }
"<="			{  return (yylval.i=LE_OP); }
">="			{  return (yylval.i=GE_OP); }
"=="			{  return (yylval.i=EQ_OP); }
"!="			{  return (yylval.i=NE_OP); }
"++"                    {  return (yylval.i=INCREMENT); }
"--"                    {  return (yylval.i=DECREMENT); }

 /* Beginning of metadata */
"[["                    {  return (yylval.i=METADATA_BEGIN); }

 /* End of line */
"\\\n"			|
[\n]			{  oslcompiler->incr_lineno(); }

 /* Ignore whitespace */
{WHITE} 		{  }

 /* catch-all rule for any other single characters */
.			{  return (yylval.i = *YYText()); }

%%


void
preprocess (const char *yytext)
{
#if 0
    printf ("preprocess: <%s>\n", yytext);
#endif
    const char *p = yytext;
    while (*p == ' ' || *p == '\t')
        p++;
    if (*p != '#') {
	fprintf (stderr, "Possible bug in shader preprocess\n");
	return;
    }
    p++;
    while (*p == ' ' || *p == '\t')
        p++;
    if (! strncmp (p, "pragma", 6)) {
	// pragma
	fprintf (stderr, "Unknown pragma '%s'\n", p);
        oslcompiler->incr_lineno();  // the pragma ends with an EOLN
    } else {  /* probably the line number and filename */
	int line = atoi (yytext+1);
        if (line > 0) {
            oslcompiler->lineno (line);
	    char *f = strchr (yytext, '\"');
	    if (f) {
                ++f;  // increment to past the quote
	        int len = 0;  // count of chars within quotes
	        while (f[len] && f[len] != '\"')
		    ++len;
	        oslcompiler->filename (ustring (f, len));
            }
	} else {
            fprintf (stderr, "Error: \"%s\", line %d:\n"
                     "\tUnrecognized preprocessor command: #%s\n",
                     oslcompiler->filename().c_str(), oslcompiler->lineno(), p);
        }
    }
}
