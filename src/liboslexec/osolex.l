/** Lexical scanner for OpenShadingLanguage 'object' files
 **/

/*****************************************************************************
 *
 *             Copyright (c) 2009 Sony Pictures Imageworks, Inc.
 *                            All rights reserved.
 *
 *  This material contains the confidential and proprietary information
 *  of Sony Pictures Imageworks, Inc. and may not be disclosed, copied or
 *  duplicated in any form, electronic or hardcopy, in whole or in part,
 *  without the express prior written consent of Sony Pictures Imageworks,
 *  Inc. This copyright notice does not imply publication.
 *
 *****************************************************************************/


/************************************************************
 * Definitions section
 ************************************************************/


/* Option 'noyywrap' indicates that when EOF is hit, yyin does not 
 * automatically reset to another file.
 */
%option noyywrap

 /* Option 'prefix' creates a C++ lexer with the given prefix, so that
  * we can link with other flex-generated lexers in the same application
  * without name conflicts.
  */
%option prefix="oso"


 /* Define regular expression macros 
  ************************************************/

 /* white space, not counting newline */
WHITE           [ \t\v\f\r]+
 /* alpha character */
ALPHA           [A-Za-z]
 /* numerals */
DIGIT           [0-9]
 /* Integer literal */
INTEGER         {DIGIT}+
 /* floating point literal (E, FLT1, FLT2, FLT3 are just helpers) */
E               [eE][-+]?{DIGIT}+
FLT1            [-+]?{DIGIT}+\.{DIGIT}*{E}?
FLT2            [-+]?{DIGIT}*\.{DIGIT}+{E}?
FLT3            [-+]?{DIGIT}+{E}
FLT             {FLT1}|{FLT2}|{FLT3}
 /* string literal */
STR     \"(\\.|[^\\"])*\"
STRDUMMY \"(\\.|[^\\"])*\"
 /* Dumb note: STRDUMMY is just to fix my syntax highlighting in emacs,
  * which is thrown off by the odd number of quotes!
  */

 /* Identifier: alphanumeric, may contain digits after the first character.
  * Also '$' is allowed!
  */
IDENT           ({ALPHA}|[_$])({ALPHA}|{DIGIT}|[_$])*
 /* C preprocessor (cpp) directives */
COMMENT         \#[^\n]*\n
 /* Hints */
HINTPATTERN     \%{IDENT}(\{[^\}]*\})?


 /* Note for lex newbies: the following '%{ .. %}' section contains literal
  * C code that will be inserted at the top of code that flex generates.
  */
%{
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <string>

#include <OpenImageIO/ustring.h>

#include "osl_pvt.h"
using namespace OSL;
using namespace OSL::pvt;

#include "osogram.hpp"   /* Generated by bison/yacc */

#define yylval osolval

%}

/* Declare modes */
%s DECLARATION


%%

 /************************************************
  * Lexical matching rules
  ************************************************/

 /* Comments */
{COMMENT}               {  /* skip it */ }

 /* keywords */
<DECLARATION>"closure"	{  return (yylval.i=CLOSURE); }
<DECLARATION>"color"	{  return (yylval.i=COLORTYPE); }
<DECLARATION>"float"	{  return (yylval.i=FLOATTYPE); }
<DECLARATION>"int"      {  return (yylval.i=INTTYPE); }
<DECLARATION>"matrix"	{  return (yylval.i=MATRIXTYPE); }
<DECLARATION>"normal"	{  return (yylval.i=NORMALTYPE); }
<DECLARATION>"point"	{  return (yylval.i=POINTTYPE); }
<DECLARATION>"string"	{  return (yylval.i=STRINGTYPE); }
<DECLARATION>"struct"	{  return (yylval.i=STRUCT); }
<DECLARATION>"vector"	{  return (yylval.i=VECTORTYPE); }

^local                  {
                           BEGIN (DECLARATION);
                           yylval.i = SymTypeLocal;
                           return SYMTYPE;
                        }

^global                 {
                           BEGIN (DECLARATION);
                           yylval.i = SymTypeGlobal;
                           return SYMTYPE;
                        }

^param                  {
                           BEGIN (DECLARATION);
                           yylval.i = SymTypeParam;
                           return SYMTYPE;
                        }

^oparam                 {
                            BEGIN (DECLARATION);
                            yylval.i = SymTypeOutputParam;
                            return SYMTYPE;
                        }

^const                  {
                            BEGIN (DECLARATION);
                            yylval.i = SymTypeConst;
                            return SYMTYPE;
                        }

^code                   {
                            BEGIN (INITIAL);
                            return yylval.i = CODE;
                        }

 /* Identifiers */
{IDENT}	                {
                            yylval.s = ustring(YYText()).c_str();
                            // std::cerr << "lex ident '" << yylval.s << "'\n";
                            return IDENTIFIER;
                        }

 /* Literal values */
{INTEGER}               {
                            yylval.i = atoi (YYText());
                            // std::cerr << "lex int " << yylval.i << "\n";
                            return INT_LITERAL;
                        }

{FLT}                   {
                            yylval.f = atof (YYText());
                            // std::cerr << "lex float " << yylval.f << "\n";
                            return FLOAT_LITERAL;
                        }

{STR}                   {
                            // grab the material between the quotes
                            ustring s (YYText(), 1, strlen(YYText())-2);
                            yylval.s = s.c_str();
                            // std::cerr << "lex string '" << yylval.s << "'\n";
                            return STRING_LITERAL;
                        }

{HINTPATTERN}           {
                            ustring s (YYText());
                            yylval.s = s.c_str();
                            return HINT;
                        }

 /* Ignore whitespace */
{WHITE} 		{  }

 /* Ignore a linefeed that ends with a trailing blackslash */
"\\\n"		        {  }

 /* End of line */
[\n]			{
                            std::cerr << "lex end of line\n";
                            return ENDOFLINE;
                        }

 /* catch-all rule for any other single characters */
.			{  return (yylval.i = *YYText()); }

%%


